---
title: "Check consent"
---

# Purpose

The consent data set does not contain all of the Medstar IDs that are contained in the other data sets downloaded from FileMaker Pro. The purpose of the code in this file is to inventory the Medstar IDs that are not found in the consent data set and make sure they shouldn't be included in the count of DETECT follow up interviews completed.


# Load Packages

```{r}
library(dplyr, warn.conflicts = FALSE)
library(readr)
library(purrr)
```

# Load data

Load the data table into the global environment as a data frame using the raw csv file. See this Wiki page for more information about the location of the data: https://github.com/brad-cannell/detect_fu_interviews_public/wiki. 

```{r}
names_paths <- c(
  "aps" = "aps_investigations_import.rds",
  "con" = "consent_import.rds",
  "cls" = "clutter_scale_import.rds",
  "glh" = "general_health_import.rds",
  "lpa" = "lead_panel_assessment_import.rds",
  "obs" = "observational_measures_import.rds",
  "par" = "participant_import.rds",
  "sfr" = "self_report_import.rds",
  "soc" = "sociodemographic_information_import.rds",
  "detect_fu_data_merged" = "detect_fu_data_merged.rds"
)
```

```{r}
#| message: false

iwalk(
  names_paths,
  # When using iwalk with an anonymous function as we do below, .x refers to 
  # the element of the vector passed to the .x argument and .y refers to the
  # index. When we pass a named vector to the .x argument, then the index is
  # The element's name.
  ~ {
    # Get the path for the current data set
    path <- here::here("data", "cleaned_rds_files", .x)
    # Get the data
    df <- readr::read_rds(path)
    # Print the dimensions of the data for future data checks
    cat(.y, ":", dim(df), "\n")
    # Assign the data to the global environment
    assign(.y, df, envir = globalenv())
  }
)

# aps : 951 22 
# con : 1013 17 
# cls : 893 29 
# glh : 955 105 
# lpa : 6838 38 
# obs : 935 132 
# par : 92160 84 
# sfr : 956 351 
# soc : 963 52 
# detect_fu_data_merged : 98200 799 
```


# Create a list of data frame names

Create a list of data frame names that we will iterate over below. The list should include all of the data frames in `names_paths` except `detect_fu_data_merged`.

```{r}
df_names <- names(names_paths)
df_names <- df_names[df_names != "detect_fu_data_merged"]
```

```{r}
# No longer need names_paths
rm(names_paths)
```


# List all MedStar ids

Create a named list containing the unique MedStar ids that are present in each of the cleaned data frames.

```{r}
medstar_ids_list <- map(
  df_names,
  ~ get(.x)[["medstar_id"]] |> unique()
) |> 
  set_names(df_names)
```


# List missing MedStar ids

Create named list containing all of the MedStar ids that exist in each of the follow-up interview data frames, but do not exist in the consent data frame.

```{r}
medstar_ids_not_in_con <- map(
  df_names,
  ~ setdiff(medstar_ids_list[[.x]], medstar_ids_list[["con"]])
) |> 
  set_names(df_names)
```

Convert the list of MedStar ids to a data frame that is easier to work with. 
- The first column will contain the name of the data frame that contains the MedStar id.
- The second column will contain the MedStar id that wasn't found in the consent data frame.
- We will drop all rows from the participant data frame (`par`). Most of those encounters did not receive a follow-up interview by design.

```{r}
medstar_ids_not_in_con <- medstar_ids_not_in_con |> 
  stack() |> 
  select(df = ind, medstar_id = values) |> 
  filter(df != "par")
```

```{r}
# medstar_ids_not_in_con["par"]
medstar_ids_not_in_con[!names(medstar_ids_not_in_con) == "par"]

```



```{r}

setdiff(unique(medstar_ids_not_in_con$medstar_id), unique(comparisons$ID))
```

```{r}
sfr |> 
  filter(is.na(medstar_id))
```



# ðŸ”´ Left off here. 
- Trying to recreate Ebie's results.
- She didn't include `par` in her comparisons. I should drop it from ours.
- There is an NA value in the sfr data frame. I need to go remove that row and then come back to this code.





```{r}
# Create vectors, each containing the medstar IDS for each DETECT FU data set.
vec_list <- list(aps_id = aps, cls_id = cls, glh_id = glh, lpa_id = lpa, obs_id = obs, par_id = par, sfr_id = sfr, soc_id = soc, con_id = con)

medstar_id_lists <- lapply(vec_list, function(vec) {
  vec_ID <- unique(vec$medstar_id)
})

# Push the vectors to the Global environment
list2env(medstar_id_lists, envir = .GlobalEnv)
```

```{r}
#  List of vectors to check consent vector against
vec_ref_list <- list(
  aps_id = aps_id, cls_id = cls_id, glh_id = glh_id, lpa_id = lpa_id, obs_id = obs_id,
  sfr_id = sfr_id, soc_id = soc_id, con_id = con_id
)

# Function for comparing 2 vectors
compare_vec <- function(vec, ref_vec) {
  comparison_column <- full_join(data.frame(key = ref_vec, ref_vec),
    data.frame(key = vec, vec),
    by = "key"
  ) %>%
    select(-key) %>%
    mutate(
      in_both = case_when(
        is.na(ref_vec) == T & is.na(vec) == F ~ "Only in this dataset",
        is.na(ref_vec) == F & is.na(vec) == T ~ "Only in dataset being compared to",
        ref_vec == vec ~ "In both"
      ),
      in_both = factor(in_both,
        levels = c("In both", "Only in this dataset", "Only in dataset being compared to")
      )
    )
  comparison_column
}


# Apply the compare_vec function to the consent vector to produce a list of comparison outputs.
comparisons <- lapply(vec_ref_list, compare_vec, vec = con_id)
```

```{r}
comparisons <- comparisons %>%
  # Filter all the dataframes for medstar_ids "Only in dataset being compared to"
  map(., ~ filter(.x, in_both == "Only in dataset being compared to")) %>%
  # Remove dataframes with empty rows
  purrr::keep(., ~ nrow(.) > 0) %>%
  # Bind filtered rows together
  do.call(rbind, .) %>%
  # make row names column
  tibble::rownames_to_column() %>%
  select(c(rowname, ref_vec)) %>%
  rename(
    "dataframe" = "rowname",
    "ID"        = "ref_vec"
  ) %>%
  mutate(
    dataframe = gsub("_id.*", "", dataframe)
  )
```

```{r}
# Check participant consent in the other data sets
check_error_message <- detect_fu_data_merged %>%
  filter(medstar_id %in% comparisons$ID) %>%
  select(c(medstar_id, contains("x_error_message"))) %>%
  left_join(comparisons, by = c("medstar_id" = "ID"))

check_error_message
```
```{r}
# Filter MedStar IDs that don't have the error message "Participant consent not recorded" for any of the datasets
no_error <- check_error_message %>% filter(if_all(contains("x_error_message"), ~ is.na(.) == T))
no_error
```

Two of the 13 MedStar IDs don't have the error message "Participant consent not recorded" for any of the datasets.
Both medstar_ids are in the observational measures data set.

```{r}
# check the status of these medStar IDs in the observational measures dataset
check_obs <- detect_fu_data_merged %>%
  filter(medstar_id %in% no_error$medstar_id) %>%
  select(x_record_status_obs)
check_obs
```
Both have incomplete status. 

# Conclusion
None of the Medstar IDs not found in the consent dataset need to be included in the count of DETECT follow up interviews completed.
