---
title: "Cleaning APS"
html:
  embed-resources: true
format: html
---

# ‚≠êÔ∏è Overview

The APS records data set was divided into 5 separate, interconnected excel files. These files (WILL BE) documented in the [wiki](https://github.com/brad-cannell/detect_fu_interviews_public/wiki). The primary file of interest for subject-level linkage is the "Clients.xlsx" file. This file contained 568,562 observations of 11 variables, including 378,418 values for `client_id`.


## Data Wrangling

-   Placeholder

    -   Placeholder

## Data Cleaning

-   Placeholder

# üì¶ Load Packages and Functions

## Library Imports

```{r, warning = FALSE}

suppressPackageStartupMessages({
  library(tidyverse)
  library(readxl)
  library(here)
  library(data.table)
})

```

## Functions

```{r}
# Function to consolidate and count unique values found in variable(s)
source(here::here("r", "get_unique_value_summary.R"))
```


Placeholder

# üì• Load Data

## APS "Client.xlsx"

APS client data was loaded for processing from XLSX format. Data types were specified for key fields to minimize loss of data, such as in date formats. We also standardized variable naming into lowercase, replacing spaces with underscores and eliminating "\r\n" elements of names (which represent Microsoft Formatting).

We anticipated an error in row 144,102 for column C ("Client ID") as the Excel document has it listed as "blank".

```{r}
aps_path <- here::here("data","DETECT Shared with APS","Clients.xlsx")
aps <- readxl::read_excel(aps_path,
                  sheet = "Client Detail",
                  col_types = c(
                    "numeric", "numeric", "date", rep("text",8)
                    )
                  ) |>
       dplyr::rename_with( ~ tolower(gsub(" ", "_", .x, fixed = TRUE))) |>
       dplyr::rename_with( ~ tolower(gsub("\r\n", "", .x, fixed = TRUE)))

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "APS data imported with", nrow(aps), "rows and", ncol(aps), "columns.\n",
  "Data last modified on OneDrive",
  as.character(file.info(aps_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (aps_path)


# Warning: Expecting numeric in B144102 / R144102C2: got 'blank'
# 2024-05-22: APS data imported with 568562 rows and 11 columns.
# Data last modified on OneDrive 2024-03-21 18:35:52 
```

## USPS Zip Code Validation Data

The United States Postal Service releases an Excel file detailing ZIP Codes with their associated Area and District Codes. This includes State data for a State-level verification of Zip Code values. This file used the version obtained on the [USPS website](https://postalpro.usps.com/ZIP_Locale_Detail), last updated May 03, 2024.

```{r}
usps_path <- here::here(
  "data", "verification_data", "USPS_ZIP_Locale_Detail.xls"
  )

usps_zip <- readxl::read_excel(usps_path,
  # Select only the desired data
                  col_types = c(
                    rep("skip", 4), "text", rep("skip", 2), rep("text", 3),
                    "skip"
                    ),
                  col_names = c(
                    'delivery_zip', 'city', 'state', 'phys_zip'
                    ),
                  # skips row of headers
                  skip = 1
                  ) |>
  # Remove rows with duplicated rows
  dplyr::distinct()

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "USPS Zip Code data imported with", nrow(usps_zip), "rows and", ncol(usps_zip), "columns.\n",
  "Data last modified on OneDrive",
  as.character(file.info(usps_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (usps_path)


# 2024-05-22: USPS Zip Code data imported with 43307 rows and 4 columns.
# Data last modified on OneDrive 2024-05-06 14:48:02 
```

We performed a modification of the USPS data so that it acted as a dictionary, with the zip code as the unique key.

```{r}
# Alter data so that ZIP CODE acts as a key, indicating the state associated
# with each ZIP CODE for Delivery (service) area and Physical (actual
# location of service delivery) for each ZIP CODE.

usps_zip <- dplyr::full_join(
  # Isolate State for Each Physical Zip Code
  usps_zip |>
    dplyr::select('state', 'phys_zip') |>
    dplyr::distinct() |>
    dplyr::rename_at(
      c('state', 'phys_zip'),
      ~c('usps_state_phys', 'client_zip_code')
    ) |>
    # Change value for any repeated Zip Code (multiple States for Physical)
    # so that each Zip is only present once
    dplyr::mutate(usps_state_phys = ifelse(
      (
        duplicated(client_zip_code)|
        duplicated(client_zip_code, fromLast = TRUE)
       ),
       'Multiple',
       usps_state_phys
      )
      ) |>
    dplyr::distinct(),
  # Isolate State for Each Delivery Zip Code
  usps_zip |>
    dplyr::select('state', 'delivery_zip') |>
    dplyr::distinct() |>
    dplyr::rename_at(
      c('state', 'delivery_zip'),
      ~c('usps_state_delivery', 'client_zip_code')
    ) |>
    # Change value for any repeated Zip Code (multiple States for Physical)
    # so that each Zip is only present once
    dplyr::mutate(usps_state_delivery = ifelse(
      (
        duplicated(client_zip_code)|
          duplicated(client_zip_code, fromLast = TRUE)
        ),
       'Multiple',
       usps_state_delivery
      )
      ) |>
    dplyr::distinct(),
  by = 'client_zip_code'
)
```

## County Data

We previously isolated a list of all counties in Texas using the [Texas Health and Human Services list of Texas Counties and Public Health Regions](https://www.dshs.texas.gov/center-health-statistics/center-health-statistics-texas-county-numbers-public-health-regions). As Texas HHS notes, counties may have a variety of valid spellings so counties which do not match the list are not necessarily invalid.

```{r}
county_path <- here::here(
  "data", "verification_data", "txhhs_ph_regions.csv"
  )

county_list <- readr::read_csv(county_path)

# Convert to 1 dimensional vector listing county names, values standardized
# into lowercase

county_list <- unique(tolower(county_list$county_name))

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "TX HHS PH data imported with", length(county_list), "entries.\n",
  "Data last modified on OneDrive",
  as.character(file.info(county_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (county_path)


# 2024-05-24: TX HHS PH data imported with 254 entries.
# Data last modified on OneDrive 2024-05-24 15:36:26
```

## Municipality Data

We had previously extracted a table listing Texas Cities and their counties, obtained from a PDF of [Texas Department of Transportation Records for Cities and Towns](https://ftp.txdot.gov/pub/txdot-info/tpp/county_maps/cities_towns.pdf).

```{r}
city_path <- here::here(
  "data", "verification_data", "txdot_cities_towns.csv"
  )

cities <- readr::read_csv(city_path, show_col_types = FALSE) |>
  # Convert all values to lowercase
  dplyr::mutate(dplyr::across(dplyr::everything(), ~tolower(.x)))

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "TXDOT County & Municipality data imported with", nrow(cities), 
  "rows and", ncol(cities), "columns. \n",
  "Data last modified on OneDrive",
  as.character(file.info(city_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (city_path)


# 2024-05-24: TXDOT County & Municipality data imported with 3328 rows and 2 
# columns.
# Data last modified on OneDrive 2024-05-24 15:31:22
```

# Initial Data Structure

## APS Data

The APS client data set contained 568,562 observations for 11 variables.

```{r}
dim(aps)

# [1] 568562     11
```

This included 378,418 unique Client ID values, which should be unique to each subject.

```{r}
length(unique(aps$client_id))

# [1] 378418
```

There was only one observation which was missing a value for Client ID, which was anticipated (was entered as "blank" in original Excel document).

```{r}
nrow(aps |>
       dplyr::filter(is.na(aps$client_id))
     )

# [1] 1
```

Per APS documentation (see notes documents in data folders), each APS Case should have one Client ID (Clients may have more than one Case, each Case only has one client, One-to-Many relationship of Client-Case). The data set initially included 568,385 values for Case ID, indicating some Case IDs possibly represented more than one observation (and thus possibly more than one Client ID was assigned to a Case ID).

```{r}
length(unique(aps$case_id))

# [1] 568385
```

There were 290,004 observations that contained a duplicated Client ID.

```{r}
nrow(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         )
     )

# [1] 290004
```

This represented 99,860 Client IDs and 289,975 Case IDs.

```{r}
cat("Client IDs:", 
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         ) |>
         dplyr::select(client_id)
      )),
    ";", "Case IDs:",
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         ) |>
         dplyr::select(case_id)
      ))
    )

# Client IDs: 99860 ; Case IDs: 289975
```

There were 351 observations that contained a duplicated Case ID.

```{r}
nrow(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         )
     )

# [1] 351
```

This represented 99,860 Client IDs and 289,975 Case IDs. This indicated likely "failed matches" (one subject represented by more than one Client ID), likely due to human/system error in data entry.

```{r}
cat("Client IDs:", 
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         ) |>
         dplyr::select(client_id)
      )),
    ";", "Case IDs:",
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         ) |>
         dplyr::select(case_id)
      ))
    )

# Client IDs: 349 ; Case IDs: 174
```

There were 27,161 unique values in the field for first names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_first_name') |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 27161
```

There were 7,588 unique values in the field for middle names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_middle_name') |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 7588
```

There were 57,846 unique values in the field for middle names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_last_name') |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 57846
```

# Data Validation and Modification

Data required some validation and modification to maximize returns from fastLink processing. First, all leading and trailing white space was removed from any string values, and values were converted to lowercase.

```{r}
aps <- aps |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~tolower(stringr::str_trim(., side = 'both'))
                ))
```

We also reduced any instances of multiple white spaces ("  ") into a single white space, for consistency.

```{r}
aps <- aps |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~stringr::str_replace_all(.x, "( {2,})", " ")
                ))
```

We standardized single quotes, so that ‚Äô, ‚Äò, and ' were all standardized to '. We similarly standardized double quotes, so that ‚Äú,‚Äù and " were all standardized to ". 

```{r}
aps <- aps |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~stringr::str_replace_all(.x, "(‚Äô|‚Äò)", "'")
                )) |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~stringr::str_replace_all(.x, '(‚Äú|‚Äù)', '"')
                ))
```


## Addition of Columns

We added a notes column, which would allow us to shift any potentially valuable information for reconciliation into our data set, which is stored in the wrong field or otherwise would complicate implementation of fuzzy-matching algorithms.

We also added separate address fields in anticipation of address cleaning: one for PO Boxes, one for business/building name or other such identifiers, and one each for secondary address classifier and value (such as "Apartment" and the corresponding Apartment number value).

```{r}
aps <- aps |>
  dplyr::mutate(
    client_notes = NA_character_,
    client_pobox = NA_character_,
    client_street_address_name = NA_character_,
    client_street_address_scnd1_type = NA_character_,
    client_street_address_scnd1_val = NA_character_,
    client_street_address_scnd2_type = NA_character_,
    client_street_address_scnd2_val = NA_character_,
  )
```

## Name Fields

Names values were already separated into First, Middle Initial, and Last.

### "Unknown"

We inspected name values for "Unknown", a common placeholder that is better represented by a missing value. We found 75 observations with a potential value for "Unknown" in at least one name field.

```{r}
target_regex <- "(unkn)|(don't)|(homel)|(unk\\.)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 75
```

Several of these observations had potentially valuable information for subject matching, specifically "male" or "female" in one of the name fields along with a value for "unknown". We shifted these gender values into a notes column, and converted those values to missing (`NA`) values.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_, 
    client_msc_first = NA_character_,
    client_msc_last = NA_character_,
    client_msc_middle = NA_character_
  ) |>
  # Shift from first, middle, and last name field to a notes column
  dplyr::mutate(
    # Shift "male" or "female" from first name to notes field
    client_msc_first = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_first_name == 'male' ~ 'male', 
        client_first_name == 'female' ~ 'female',
        TRUE ~ client_msc_first
      ),
      client_msc_first),
    client_first_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_first_name == 'male' ~ NA_character_,
        client_first_name == 'female' ~NA_character_,
        TRUE ~ client_first_name
      ),
      client_first_name
      )
  ) |>
  dplyr::mutate(
    # Shift "male" or "female" from Middle name to notes field
    client_msc_middle = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_middle_name == 'male' ~ 'male', 
        client_middle_name == 'female' ~ 'female',
        TRUE ~ client_msc_middle
      ),
      client_msc_middle),
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_middle_name == 'male' ~ NA_character_,
        client_middle_name == 'female' ~NA_character_,
        TRUE ~ client_middle_name
      ),
      client_middle_name
      )
  ) |>
  dplyr::mutate(
    # Shift "male" or "female" from last name to notes field
    client_msc_last = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_last_name == 'male' ~ 'male', 
        client_last_name == 'female' ~ 'female',
        TRUE ~ client_msc_last
      ),
      client_msc_last),
    client_last_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_last_name == 'male' ~ NA_character_,
        client_last_name == 'female' ~NA_character_,
        TRUE ~ client_last_name
      ),
      client_last_name
      )
  ) |>
  # Collect data into a single, neat notes column with NAs omitted
  dplyr::mutate(
    client_msc = paste(
      client_msc_first, client_msc_middle, client_msc_last, 
      sep = "; "
      ),
    client_msc = stringr::str_remove_all(client_msc, "NA; "),
    client_msc = stringr::str_remove_all(client_msc, "; NA"),
    client_msc = stringr::str_remove_all(client_msc, "NA"),
    client_msc = ifelse(client_msc == '', NA_character_, client_msc)
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(
    client_msc, client_msc_first, client_msc_middle, client_msc_last
    )
  )
```

A point-fix was utilized to correct the only entry with "don't know" in a name field.

There were also several observations that contained "unknown" in one name field with either "person" or "ward" as the only other potentially informative value, both of which were better expressed as missing (`NA`) values in this context. There were no names such as "Edward" that would otherwise be valid but caught in our regular expressions within this set. üî¥ Any modification to this data processing pipeline should include verification that this is still true to avoid loss of valuable data.

```{r}
aps <- aps |>
  # "don't know" in middle name
  dplyr::mutate(
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      ifelse(
        client_middle_name == "don't know",
        NA_character_,
        client_middle_name
      ),
      client_middle_name
      )
  ) |>
    # Remove names that are "person" or "ward" that were caught in "Unknown"
    # name checks
  dplyr::mutate(
    # First name
    client_first_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_first_name, '(person)') ~ NA_character_, 
        stringr::str_detect(client_first_name, '(ward)') ~ NA_character_,
        TRUE ~ client_first_name
      ),
      client_first_name),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_middle_name, '(person)') ~ NA_character_,
        stringr::str_detect(client_middle_name, '(ward)') ~NA_character_,
        TRUE ~ client_middle_name
      ),
      client_middle_name
      ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_last_name, '(person)') ~ NA_character_,
        stringr::str_detect(client_last_name, '(ward)') ~NA_character_,
        TRUE ~ client_last_name
      ),
      client_last_name
      )
  )
```

We were then able to set any of our "unknown" name values to missing values, maintaining helpful data.

```{r}
aps <- aps |> 
  dplyr::mutate(
    client_first_name = ifelse(
      stringr::str_detect(client_first_name, target_regex),
      NA_character_,
      client_first_name
    ),
    client_middle_name = ifelse(
      stringr::str_detect(client_middle_name, target_regex),
      NA_character_,
      client_middle_name
    ),
    client_last_name = ifelse(
      stringr::str_detect(client_last_name, target_regex),
      NA_character_,
      client_last_name
    )
  )
```

We additionally identified 8 rows with a name value of "none". We isolated these observations for manual examination.

```{r}
target_regex <- "^(none)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 8
```

We determined that all of the "none" values likely represented an "unknown" value, and converted those values to missing values.

```{r}
aps <- aps |> 
  dplyr::mutate(
    client_first_name = ifelse(
      stringr::str_detect(client_first_name, target_regex),
      NA_character_,
      client_first_name
    ),
    client_middle_name = ifelse(
      stringr::str_detect(client_middle_name, target_regex),
      NA_character_,
      client_middle_name
    ),
    client_last_name = ifelse(
      stringr::str_detect(client_last_name, target_regex),
      NA_character_,
      client_last_name
    )
  )
```

Due to the US convention of naming unknown subjects "Jane Doe" or "John Doe", we checked for rows where the last name was "doe". These 6 rows were isolated for manual review. All appeared to be potentially valid instances of a subject with the last name of "Doe", rather than an anonymous placeholder.

```{r}
checking <- aps |> 
  dplyr::filter(
    client_last_name == 'doe'
    )

nrow (checking)

# [1] 6
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

### Numbers in Names

In previous checks, several name fields were identified which had numbers rather than name data. Names do not typically contain numerical digits, but numerical digits may frequently occur as a typographical or system error in entry. We isolated 11 entries with a numerical digit in any name field.

```{r}
target_regex <- "([0-9]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 11
```

There were two observations that merited a point-fix to shift potentially useful data into our notes field.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_, 
  ) |>
  dplyr::mutate(
    # Subject with a name of "trailer #10"
    client_msc = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      'trailer #10',
      client_msc
      ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      NA_character_,
      client_first_name
      ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      NA_character_,
      client_last_name
      ),
    # Possibly important numbers in a last name
    client_msc = ifelse(
      case_id %in% checking$case_id & client_last_name == "44947",
      '44947',
      client_msc
      ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "44947",
      NA_character_,
      client_last_name
      )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```


Numbers were otherwise omitted from all name fields. Empty strings were converted into missing values.

```{r}
 aps <- aps |>
  dplyr::mutate(
    client_first_name = stringr::str_remove_all(
      client_first_name, target_regex
      ),
    client_middle_name = stringr::str_remove_all(
      client_middle_name, target_regex
      ),
    client_last_name = stringr::str_remove_all(
      client_last_name, target_regex
      )
  ) |>
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

### Unexpected Characters (non A-Z or a-z)

We expected most, if not all, names in our subset to consist only of the letters A-Z without special characters, punctuation, or other characters.

#### Hyphens (-)

The most common character we expected to be validly present was a hyphen (-), due to traditions of hyphenating names. We isolated 4,785 entries with a hyphen in any name field for manual review.

```{r}
target_regex <- "([-]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 4785
```
 
While all 4,785 observation had a valid use of hyphens, some modification was still required due to the inconsistent use of white space with hyphenated names (i.e. Smith-Jones as "smith- jones", "smith -jones", or "smith-jones"). As such, we stripped white space surrounding hyphens from observations in our data set. This was complicated due to valid use of hyphens and spaces in multi-part names (e.g. "de la cruz- smith") in first and last name fields.
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, ' -', '-'),
      client_first_name
    ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, '- ', '-'),
      client_first_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, ' -', '-'),
      client_last_name
    ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, '- ', '-'),
      client_last_name
    )
  )
```

We checked for any instances with more than one consecutive hyphen ("--", etc.) after the initial corrections. We isolated the 8 observations for manual review.

```{r}
target_regex <- "(-{2,})"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 8
```

The instances of multiple hyphens all appeared within last name values. We adjusted these entries to ensure only a single hyphen was present.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, '-'),
      client_last_name
    )
  )
```

We checked for any instances where a hyphen was the first character in the field. We identified 0 occurrences.

```{r}
target_regex <- "^(-)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 0
```

We checked for any instances where a hyphen was the last character in the field. We identified 4 occurrences.

```{r}
target_regex <- "(-)$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 4
```

We adjusted these entries to trim the trailing hyphen.

```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, target_regex, ''),
      client_first_name
    ),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, target_regex, ''),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, ''),
      client_last_name
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Double Quote (") and quote-surrounded nicknames.
 
Several subjects appeared to have names in double quotation marks, particularly in the middle name field. These values were likely to represent nicknames or aliases. We isolated 14 entries with names surrounded by double-quotes, present in both the first and middle name fields.

```{r}
target_regex <- '(["]+)'

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 14
```
 
We shifted these likely nickname values into our notes field, and removed them from the name fields. 
 
```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_
  ) |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, '(".*?")'),
      client_msc
    ),
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, '(".*?")'),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, '(".*?")'),
      client_middle_name
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, '(".*?")'),
      client_first_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```
 
We assessed for similar entries using single quotes rather than double quotes, and found a single observation with a single quote nickname in the first name field.

```{r}
target_regex <- "('.*?')+"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 1
```

We shifted this likely nickname values into our notes field, and removed it from the name field. 
 
```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_
  ) |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, "('.*?')"),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, "('.*?')"),
      client_first_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We assessed for similar entries using parentheses rather than double quotes, and found two observations with a parenthesis surrounded nickname (first name and middle name fields)

```{r}
target_regex <- "(\\(.*?\\))+"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 2
```

We shifted these likely nickname values into our notes field, and removed them from the name fields. 
 
```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_
  ) |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, "(\\(.*?\\))"),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, "(\\(.*?\\))"),
      client_first_name
    ),
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, "(\\(.*?\\))"),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, "(\\(.*?\\))"),
      client_middle_name
    ), 
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

In the examination of name values, we also identified a single nickname that appeared to be indicated in the middle name field, preceded by "goes by". We isolated this observation for further evaluation.

```{r}
target_regex <- "goes by (.*)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 1
```

We shifted this likely nickname value into our notes field, and removed it from the middle name field. 
 
```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, "goes by (.*)"),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, "goes by (.*)"),
      client_middle_name
    ), 
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Single Quotes (')

Single quotes (') may be valid and commonly present in some names, such as in Irish and Scottish conventions (e.g. "O'Brien"). We isolated 682 entries with a single quote in any name field for manual review. 

```{r}
target_regex <- "([']+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 681
```

While most occurrences of single quotes appeared to be valid, modification was still required due to the inconsistent use of white space with single quotes in names (i.e. O'Brien as "o'brien", "o' brien", "o 'brien", or "o ' brien"). As such, we stripped white space surrounding single quotes from observations in our data set. This was complicated due to valid use of hyphens and spaces in multi-part names (e.g. "de la cruz- smith") in the name fields.

Additionally, we were unable to correct for what appeared to be usage of a single quote when a hyphen was appropriate (i.e. "Smith-Jones" as "smith'jones") due to the complexity of generating a solution without sizable point-fixes with small potential benefit to string-matching after correction.
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, " '", "'"),
      client_first_name
    ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, "' ", "'"),
      client_first_name
    ),
  # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, " '", "'"),
      client_middle_name
    ),
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, "' ", "'"),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, " '", "'"),
      client_last_name
    ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, "' ", "'"),
      client_last_name
    )
  )
```

We checked for any instances where a single quote was the first character in the field. We identified no occurrences.

```{r}
target_regex <- "^(')"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 0
```

We checked for any instances where a single quote was the last character in the field. We identified 13 occurrences.

```{r}
target_regex <- "(')$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 13
```

We adjusted these entries to trim the trailing single quote.

```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, target_regex, ''),
      client_first_name
    ),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, target_regex, ''),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, ''),
      client_last_name
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Examination for suffixes

JR and SR are common suffixes to names, but may artificially increase string-distance. We isolated 157 entries with a potential suffix match in any name field for manual review. 

```{r}
target_regex <- "((junior)|(senior)|(jr)|(sr))[^a-z]?$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 157
```

Suffix items appeared in all fields. Values were shifted from middle name and last name fields, but left in first name fields as these are also possible initial-isms or otherwise valid first names.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, target_regex),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, target_regex),
      client_middle_name
    ),
    # Extract from Last Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_match(client_last_name, target_regex),
      client_msc
    ),
    # Remove from Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_remove(client_last_name, target_regex),
      client_last_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Potential titles in name fields

Mr., Ms., Mrs., and Dr. are the primary titles used in the US. Sr. and Sra. are common Spanish-language titles used in the US. We isolated 14 potential occurrences for manual review.

```{r}
target_regex <- paste0(
  "^((doctor)|(mister)|(misus)|(miss)|(mrs)|(senora)|",
  "(senorita)|(senora)|(sra)|(ms)|(mr)|(sr)|(dr))(?![a-z]+)"
  )

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 14
```

All 11 potential titles were found in first name fields. Extraction was complicated by additional values within the field that were valuable (example: first name of "mr. smith" with no value in middle or last name fields) and values which simply required trimming (example: first name of "dr. john" with last name value of "doe").

First, we shifted desired values to our note ("client_msc") variable.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, target_regex),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, target_regex),
      client_first_name
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Name Fields:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Name Fields:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

Then, we identified our single row where there was no additional last name name information.

```{r}
target_row <- pull(aps |>
  dplyr::filter(
    (case_id %in% checking$case_id) & is.na(client_last_name)
    ) |>
  dplyr::select(case_id)
  )
```

We shifted the remaining information in the targeted observation's first name field into the last name field.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_last_name = ifelse(
      (case_id %in% checking$case_id &
        case_id == target_row),
      str_extract(client_first_name, "\\. ([a-z]+)"),
      client_last_name
    ),
    client_first_name = ifelse(
      (case_id %in% checking$case_id &
        case_id == target_row),
      NA_character_,
      client_first_name
    )
  )
```

We purged our checking subset, target regular expression, and target_row values for memory management.

```{r}
rm(checking)
rm(target_regex)
rm(target_row)
```

#### Removal of other unexpected characters

Any characters other than single quotes, hyphens, white spaces, or alphanumeric characters were no longer anticipated to be valid. We additionally set the Spanish Language character "√±" as acceptable. We isolated 2,254 potential occurrences for manual review.

```{r}
target_regex <- "([^a-z√± '-])"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 2254
```

On review, all remaining unanticipated characters to a single white space, across all name fields.

```{r}
aps <- aps |>
  # Convert non-anticipated punctuation to white space
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(
                    case_id %in% checking$case_id,
                    stringr::str_replace_all(.x, target_regex, ""),
                    .x
                    )
                  )
                )
```

We then performed cleaning: multiple white spaces were converted to a single white space; leading and trailing white spaces were trimmed; and empty strings were converted to missing values.

```{r}
aps <- aps |>
  # Trim multiple white spaces to single white space
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(
                    case_id %in% checking$case_id,
                    stringr::str_replace_all(., "( {2,})", " "),
                    .
                    )
                  )
                ) |>
  # Trim leading and trailing white spaces
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~stringr::str_trim(., side = 'both')
                  )
                ) |>
  # Convert empty strings to missing values
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(. == '', NA_character_, .)
                  )
                ) 
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

## Address Fields

### Zip Codes

We expected ZIP codes to follow a 5-digit format. Many entries contained a 5+4 format (10 character, #####-#### format). Only 7 entries did not directly match either format. These were manually reviewed.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_zip_code) < 10) |>
  dplyr::filter(nchar(client_zip_code) != 5)

nrow(checking)

# [1] 7
```

4 Zip Codes were otherwise valid, but had leading zeros truncated by Excel. These were fixed by re-adding the leading zeroes to the string value for the zip code

```{r}
aps <- aps |>
  # Add leading 0s to truncated Zip Codes.
  dplyr::mutate(client_zip_code = dplyr::case_when(
    nchar(client_zip_code) == 3 ~ paste0("00", client_zip_code),
    nchar(client_zip_code) == 4 ~ paste0("0", client_zip_code),
    TRUE ~ client_zip_code)
    ) 
```

The remaining 3 observations appeared to be fixable by truncating to 5 digits, along with the remainder of the data set's 10 character values:

-   1 Zip Code had 5 digits which appeared to be otherwise valid, with a hyphen ("-") and no 4 digit addition to the zip code. This was fixed by truncating the hyphen so only the first 5 digits were kept.

-   2 Zip Codes had all 9 digits, but without the anticipated hyphen between the 5 and 4 digit components of zip code. These were fixed by truncating so only the first 5 digits were kept.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_zip_code = ifelse(
      nchar(client_zip_code)>5,
      substr(client_zip_code, start=1, stop=5),
      client_zip_code)
  )
```

We performed a state-level verification of Zip Code data using the USPS Zip Code service data. We identified 130 observations where the Client State did not match either the USPS physical or delivery service areas based on the Zip Code.

```{r}
checking <- aps %>%
  tibble::add_column(
    usps_state_phys = NA_character_, 
    usps_state_delivery = NA_character_
    ) |>
  # Add USPS data
  dplyr::rows_update(
    usps_zip, 
     by = "client_zip_code", 
     unmatched = "ignore"
  ) |>
  # Flag mismatches between USPS and APS state based on zip code
  dplyr::mutate(
    flag_physical_zip = dplyr::case_when(
      is.na(usps_state_phys) ~ FALSE,
      (!is.na(usps_state_phys) & !is.na(client_state)) & 
        (usps_state_phys == client_state) ~
        FALSE,
      (is.na(usps_state_phys) & is.na(client_state)) ~ FALSE,
      TRUE ~ TRUE
    ),
    flag_delivery_zip = dplyr::case_when(
      is.na(usps_state_delivery) ~ FALSE,
      (!is.na(usps_state_delivery) & !is.na(client_state)) & 
        (usps_state_delivery == client_state) ~
        FALSE,
      (is.na(usps_state_delivery) & is.na(client_state)) ~ FALSE,
      TRUE ~ TRUE
    ),
    flag_zip = ifelse(flag_physical_zip | flag_delivery_zip, TRUE, FALSE),
    # If it matched either physical or delivery, unflag the row
    flag_zip = dplyr::case_when(
      !is.na(usps_state_phys) & !flag_physical_zip ~ FALSE,
      !is.na(usps_state_delivery) & !flag_delivery_zip ~ FALSE,
      TRUE ~ flag_zip
    )
  ) |>
  # Extract only the flagged observations
  dplyr::filter(flag_zip) |>
  # Reorder variables for ease of manual checking
  dplyr::relocate(
    flag_zip, flag_physical_zip, flag_delivery_zip, client_zip_code,
    usps_state_phys, usps_state_delivery,
    client_city, client_county, client_state, client_street_address
    ) |>
  dplyr::arrange(client_zip_code)

nrow(checking)

# [1] 130
```

Manual review involved searching for street addresses (if provided) using Google Maps and comparison against remainder of the APS provided address data fields. The vast majority of point fixes involved an minor typographical error, or unusual entry of data (such as states within city fields). 

Point-fixes were made by calling data from the "checking" subset to avoid overwriting other entries with identical values for Case ID that were not flagged for manual review, minimizing collateral changes to the data.

There were 87 observations that were deemed to require no revision, largely due to ZIP codes that were along state borders (thus postal service crossed state lines for the given location). There were 6 observations with issues that were unable to be resolved, largely due to missing street addresses and/or conflicting results when searching for a reliable match. There were 37 observations that received point-fixes.

```{r}
# ZIP 28207 to 78207 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '28207') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78207'

# ZIP 32667 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '32667') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_


# ZIP 46502 to 76502 (3 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '46502') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76502'


# Entry for ZIP 48202 to City "DETROIT", State "MI", 
#county "OUT OF STATE" (2 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_city'] <- 'detroit'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'mi'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

# ZIP 64114 to 77831 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '64114') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '77831'

# ZIP 67026 to 76028 (3 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '67026') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76028'

# Entry for ZIP 70125 State to "LA" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70125') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'la'

# ZIP 70526 to 78526 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70526') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78526'

# ZIP 70602  to 76579 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70602') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76579'

# Entry for ZIP 73840 to 71854, state "AR", County "OUT OF STATE" (3 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'ar'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '71854'


# ZIP 74067 to 78067 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74067') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78067'

# ZIP 74543 to 78543 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74543') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78543'

# ZIP 74756 state to OK (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74756') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'ok'

# ZIP 78368 to a missing value (4 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78368') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# Entry for ZIP 78595 state "TX", county to a missing value (4 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78595') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'tx'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78595') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- NA_character_

# Entry for ZIP 80102 to 79045, county to "DEAF SMITH" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80102') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'deaf smith'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80102') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '79045'

# ZIP 80134 to 76201 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80134') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76201'

# Entry for ZIP 82331 state to "WY" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '82331') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'wy'

# Entry for ZIP 87575 state to 'NM', county to 'OUT OF STATE' (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '87575') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'nm'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '87575') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

# Entry for ZIP 88063 state to "NM" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '88063') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'nm'

# ZIP 88125 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '88125') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# ZIP 89420 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '89420') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# ZIP 97524 to 78852 (2 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '97524') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78852'

```

We purged the USPS ZIP code data and our checking subset for memory management.

```{r}
rm(usps_zip)
rm(checking)
```

### States

We expected all values for state to represent US state values in two-character format (example: "TX") per [USPS standards](https://about.usps.com/who/profile/history/state-abbreviations.htm). With the inclusion of Puerto Rico (PR), District of Columbia (DC), and missing values (`NA`), we had 53 anticipated values. We isolated counts of our 62 unique state values for manual review.


```{r}
checking <- get_unique_value_summary(aps, 'client_state')

nrow(checking)
# [1] 62
```

All unanticipated values started with 'x' or 'z'. These 184 occurrences were isolated for further manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    (stringr::str_starts(client_state, 'x') | 
       (stringr::str_starts(client_state, 'z'))
     )
    ) |>
  dplyr::arrange(client_state)

nrow(checking)

# [1] 184
```

Point fixes were determined and executed, with creation of a "Country" column:

-   "xd" and "zc" referred to addresses in Mexico
-   "xe" referred to addresses in Mexico and Peru

    -   Additional cleaning of the city was required for the Peru entries, which gave the city as "lima, peru"
    
-   "xf" referred to addresses in Great Britain
-   "za" referred to addresses in Canada
-   "ze" referred to addresses in Russia
-   "zh" referred to addresses in Honduras
-   "zj" referred to addresses in Lagos
-   "zl" referred to addresses in Taiwan

    -   Additional cleaning of the city was required as the city was given as "Taipei, Taiwan"

```{r}
aps <- aps |>
  # Initialize empty "Country" column
  dplyr::mutate(
    client_country = NA_character_
  ) |>
  dplyr::mutate(
    # "xe" entries for Lima, Peru
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xe' & client_city == "lima, peru"),
        'peru',
        client_country
      ),
    client_city = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xe' & client_city == "lima, peru"),
        'lima',
        client_city
      ),
    client_state = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xe' & client_city == "lima"),
        'resolved',
        client_state
      )
  ) |>
  dplyr::mutate(
  # "xd", xe", and "zc" entries for Mexico
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state %in% c('xd', 'xe', 'zc')),
        'mexico',
        client_country
      ),
# "xf" entries for Great Britain
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xf'),
        'great britain',
        client_country
      ),
  # "za" entries for Canada
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'za'),
        'canada',
        client_country
      ),
  # "ze" entries for Russia
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'ze'),
        'russia',
        client_country
      ),
    # "zh" entries for Honduras
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zh'),
        'honduras',
        client_country
      ),
    # "zj" entries for Lagos
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zj'),
        'lagos',
        client_country
      ),
    # "zl" entries for Taiwan
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zl'),
        'taiwan',
        client_country
      ),
    client_city = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zl'),
        'taipei',
        client_city
      ) 
  ) |>
  # Remove cleaned state entries
  dplyr::mutate(
    client_state = ifelse(
      case_id %in% checking$case_id,
      NA_character_,
      client_state
    )
  )
```

We also checked for any observation where the value for state was missing (without a country value indicating it was an out-of-country address), but ZIP code or county were present. We found no such remaining values.

```{r}
checking <- aps |>
  dplyr::filter(
    (is.na(client_state) & is.na(client_country)) & 
      (!is.na(client_zip_code)|!is.na(client_county))
  )

nrow(checking)
# [1] 0
```

We purged our checking subset for memory management.

```{r}
rm(checking)
```

### Counties

Observations listing the state as Texas were expected to indicate a Texas County, if any county. We isolated the 546 observations wherein the listed county was not present on our Texas HHS list of Counties for manual review.

```{r}
checking <- aps |>
  dplyr::mutate(
    flag_county = FALSE
  ) |>
  dplyr::mutate(
    flag_county = ifelse(
      client_state == 'tx' & !is.na(client_county),
      ifelse(!(client_county %in% county_list),
             TRUE,
             flag_county
             ),
      flag_county
    )
  ) |>
  dplyr::filter(
    flag_county
    )

nrow(checking)
# [1] 546
```

On examination, this was due to 544 rows with a county of "de witt", and 2 with a county of "out of state". On review, "De Witt" county was contained in our verification list as "dewitt", making "de witt" valid.

```{r}
get_unique_value_summary(checking, 'client_county')
```

The two observations with values of "out of state" did indeed belong to out of state addresses, with one address belonging to Mexico. We targeted these observations for point-fixes.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_state = ifelse(
      case_id %in% checking$case_id & client_city == 'california',
      'ca',
      client_state
    ),
    client_country = ifelse(
      case_id %in% checking$case_id & client_city == 'nuevo leon',
      'mexico',
      client_country
    ),
    client_state = ifelse(
      case_id %in% checking$case_id & client_city == 'nuevo leon',
      NA_character_,
      client_state
    )
  )
```

We isolated the 1,793 observations that indicated a state of Texas but were missing a value for county for manual review. No information was contained in these observations (street address or city values) to suggest a non-Texas address. Individual street addresses were *not* individually checked using mapping software in this stage.

```{r}
checking <- aps |>
  dplyr::filter(client_state == 'tx' & is.na(client_county))

nrow(checking)
# [1] 1793
```

We isolated the 48 observations that did not indicate a state of Texas, but had a value for county that was not either a missing value or "out of state".

```{r}
checking <- aps |>
  dplyr::filter(
    (client_state != 'tx' | is.na(client_state)) &
       !is.na(client_county) & (client_county != 'out of state')
     )

nrow(checking)
# [1] 48
```

After manual review, we identified several cities which had valid counties (county with same name as a Texas county, but validly associated with the indicated city and/or zip code). We performed point fixes to an observation with an address close to a state line (state and zip code modification after address confirmation with Google Maps) and a city with a significant typo in the city name. We otherwise shifted all invalid county values to 'out of state'.

```{r}
target_cities <- c(
  'calico rock', 'debeque', 'denver', 'miramar', 'augusta', 'new orleans', 
  'new mexico', 'akron', 'unavailable', 'oklahoma', 'walters', 'yukon', 
  'varnville', 'coah'
  )

aps <- aps |>
  dplyr::mutate(
    # Fix "Anthony, NM" which refers to "Anthony, TX"
    client_zip_code = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'anthony',
      '79821',
      client_zip_code
    ),
    client_state = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'anthony',
      'tx',
      client_state
    ),
    # Fix found city name typo
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'allonia',
      'vallonia',
      client_city
    )
  ) |>
  dplyr::mutate(
    # Clear invalid county names
    client_county = ifelse(
      (case_id %in% checking$case_id) &
        client_city %in% target_cities,
      'out of state',
      client_county
    )
  )
```

We purged our target cities, list of counties, and checking subset for memory management.

```{r}
rm(checking)
rm(target_cities)
rm(county_list)
```

### Cities

We expected values for cities to contain only letters, and no value that was equivalent to "unknown". Previous exploration had identified a city with a name of "unavailable" (which did not match any city/town in the US per Google searches) and at least one observation where the city name was a spelled out version of the state, when no such city was known to exist in the state.

#### Unanticipated characters

We first identified observations with any unanticipated characters (any non-letter, except a white space). We isolated these 26 observations for manual review.

```{r}
target_regex <- "([^a-z ]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 26
```

We identified several issues which would require dedicated screening and modification: variations on "Fort Worth" or similar "Ft" or "Mt" city names, and a variation of "North Richland Hills" (caught due to periods). However, we did identify several issues (commas or backticks at the end of a city name which were likely typos, city name with a hyphen or forward slash indicating a region rather than a specific city/town) that could be fixed in this batch of corrections. We additionally performed point-fixes for observations which indicated a value in "CITY, STATE" format.

After point-fixes were made, all remaining unanticipated characters (anything other than a whitespace, single quote, or letter from a-z) were removed. Multiple white spaces were consolidated into a single white space. Leading and trailing white spaces were trimmed. Empty strings were converted to missing values.

```{r}
target_regex <- "([^a-z ']+)"

aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  dplyr::mutate(
    # Shift value for Torreon, Coahuila
    client_msc = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'torreon, coahuila',
      'torreon, coahuila',
      client_msc),
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'torreon, coahuila',
      'torreon',
      client_city),
    # Shift value for Argyle - North Lake to Argyle
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'argyle - north lake',
      'argyle',
      client_city),    
    # Shift value for Wylie/Dallas Area
    client_msc = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'wylie/dallas area',
      'wylie/dallas area',
      client_msc),
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'wylie/dallas area',
      'wylie',
      client_city),    
    # Shift value for "Dallas, Texas" in city field
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'dallas, texas',
      'dallas',
      client_city)
  ) |>
  # Remove all non-desired characters
  dplyr::mutate(
    client_city = ifelse(
      case_id %in% checking$case_id,
      stringr::str_replace_all(client_city, target_regex, ''),
      client_city
    )
  ) |>
  # Consolidate multiple white spaces into a single white space
  dplyr::mutate(
    client_city = stringr::str_replace_all(client_city, "( {2,})", " ")
  ) |>
  # Trim leading and trailing white spaces
  dplyr::mutate(
    client_city = stringr::str_trim(client_city, side = 'both')
  ) |> 
  # Convert empty strings to missing values
  dplyr::mutate(
    client_city = dplyr::na_if(client_city, '')
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("City:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; City:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

#### Prefixes and Suffixes

In previous data, city values with prefixes of "City of", "Town of", "Village of", or "Census Designated Place" as well as suffixes of "historical" were identified. We checked our current data for any such values, and found no matches.

```{r}
target_regex <- "((census)|(histor)|(village of)|(town of)|(city of))"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 0
```

#### Unknown or Equivalents

In previous exploration and cleaning, we identified a city value of "unavailable" which was not valid for any area in the US. Similarly, there is no known city named "Unknown" in the US. Previous data had values for a city of "Uncertain", which could be a valid city in a Texas. We checked our current data for any values for "unknown" or it's equivalents, isolating the 27 matches for manual review.

```{r}
target_regex <- "((unkn)|(unav)|(uncer))"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 27
```

All entries indicated an unknown value, with an equally missing or otherwise "unknown" value for street address. No potentially valid cities were identified when searching individual states. As such, we shifted all of these values to a missing value.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_city = ifelse(
      stringr::str_detect(client_city, target_regex),
      NA_character_,
      client_city
    )
  )
```

#### State Names in Cities

While there are several cities which include state names (such as Oklahoma City and New York City), there have been previously identified instances within the data set wherein a city actually includes the state name. R contains a built-in data set which includes state names and abbreviations.

```{r}
state_data <- data.frame(name = state.name, abbr = state.abb) |>
  # Convert string fields to lowercase values
  dplyr::mutate(dplyr::across(dplyr::everything(), ~tolower(.x))) |>
  # Arrange values from longest to shortest, and alphabetically within
  # the same length
  dplyr::mutate(name_length = stringr::str_length(name)) |>
  dplyr::arrange(dplyr::desc(name_length), name)
```


We checked our data for any city name that contained a state name, and found 4,861 matches. We isolated these matches for further manual review.

```{r}
target_regex <- paste0(
  "(",
  paste(state_data$name, collapse = ")|("), ")"
)

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 4861
```

While the vast majority of cities were determined to be valid, we also identified several cities which required revision. Four of these could be targeted to the city name, but additional revisions required further specification.

```{r}
target_cities <- c(
  'louisiana', 'new mexico', 'pennsylvania', 'south carolina'
  )

aps <- aps |>
  dplyr::mutate(
    # Street address includes ' santa fe', no zip code
    client_zip_code = ifelse(
      (case_id %in% checking$case_id) & client_city == 'texas' &
        (stringr::str_detect(client_street_address, ' santa fe')),
      '77510',
      client_zip_code
    ),
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '77510'),
      'santa fe',
      client_city
    ),
    client_street_address = ifelse(
      (case_id %in% checking$case_id) & client_city == 'santa fe',
      stringr::str_remove(client_street_address, ' santa fe'),
      client_street_address
    ),
  # Street address includes ", galveston"
    client_street_address = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '77551'),
      stringr::str_remove(client_street_address, ', galveston,'),
      client_street_address
    ),
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '77551'),
      'galveston',
      client_city
    ),
    # City from ZIP Code
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '79902'),
      'el paso',
      client_city
    ),
    # Oregon, NM specifically as invalid
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'oregon' & client_state == 'nm'),
      NA_character_,
      client_city
    ),    
    # Adding 'city' to 'New York' and 'Oklahoma' cities
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        (client_city %in% c('new york', 'oklahoma')),
      stringr::str_c(client_city, ' city'),
      client_city
    ),
    # Point-fix of single address, ZIP code issue
    client_zip_code = ifelse(
      (case_id %in% checking$case_id) & 
        (client_zip_code == '77831'),
      '64414',
      client_zip_code
    ),
    # Remove cities of 'florida' in the state of florida only
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        (client_city == 'florida' & client_state == 'fl'),
      NA_character_,
      client_city
    )
  ) |>
  # Broader correction based on target list
  dplyr::mutate(
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city %in% target_cities),
      NA_character_,
      client_city
    )
  )
```

We similarly checked for any values which contained the two letter state abbreviation at the end of a city value (example: "dallas tx"). We isolated the 14 matching rows for manual review.
   
```{r}
target_regex <- paste0(
  "[^a-z]+((", 
  paste(pull(state_data |> 
               dplyr::arrange(name) |> 
               dplyr::select(abbr)), 
        collapse = ")|("), 
  "))$"
  )

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 14
```

All 14 values followed the formula "city tx", and had state values of "tx". As such, we trimmed the extraneous data.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_city = ifelse(
      case_id %in% checking$case_id,
      stringr::str_remove(client_city, ' tx'),
      client_city
    )
  )
```

We purged our memory of our target regular expression, list of target cities, state name and abbreviation data, and our checking subset for memory management.

```{r}
rm(target_regex)
rm(target_cities)
rm(state_data)
rm(checking)
```

#### Standardizing Format of "Fort" and "Mt" City Names
  
In prior exploration and cleaning, we observed several components of city names which may or may not be abbreviated - with multiple formats included in values. This includes Fort Worth (abbreviated to "Ft Worth"), Mount Pleasant (abbreviated to Mt Pleasant). It also included cardinal direction indicators, such as North Richland Hills (abbreviated to N Richland Hills). This cleaning was required to minimize string distances from otherwise identical values.

We isolated the 27,681 observations which contained these values for examination.

```{r}
target_regex <- paste0(
  "^((mount)|(fort)|(ft)|(mt)|(north)|(south)|(east)|(west)|",
  "(port)|(point)|(prt)|(pnt)|(pt)|",
  "(nw )|(ne )|(sw )|(se )|(s )|(e )|(w )|(n ))"
)

checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
  )

nrow(checking)
# 27681
```

In examining these values, we find 153 unique variations of city name, and are able to identify broader trends.

```{r}
get_unique_value_summary(checking, 'client_city')
```

Before any aggregate modifications, several point-fixes were made. This was primarily to correct several misspellings, or adjust city based on zip code.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  # "WEST" Cluster
  dplyr::mutate(
    # adjust ZIP code of 76654 in 'west, tx' to 76691
    client_zip_code = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'west' & client_zip_code == 76654),
      '76691',
      client_zip_code
    ),
    # fix typo in 'columbia'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west colombia',
      'west columbia',
      client_city
    ),
    # convert 'west ingram' into 'ingram'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west ingram',
      'ingram',
      client_city
    ),
    # fix typo in 'west tawakoni'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west towankani',
      'west tawakoni',
      client_city
    ),
    # add 'city' back to 'west valley city'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west valley',
      'west valley city',
      client_city
    ),
    # adjust ZIP code of 79549 in 'westbrook, tx' to 79565
    client_zip_code = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'westbrook' & client_zip_code == 79549),
      '79565',
      client_zip_code
    ),
    # remove 'westheimer, tx' city (this is a road name)
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'westheimer',
      'westheimer',
      client_msc
    ),
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'westheimer',
      NA_character_,
      client_city
    )
  ) |>
  # SOUTH Cluster
  dplyr::mutate(
    # convert 'south austin' to 'austin'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'south austin',
      'austin',
      client_city
    ),    
    # convert 'south clifton' to 'clinton'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'south clifton',
      'clinton',
      client_city
    ),    
    # convert 'south haven' to 'southaven'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'south haven',
      'southaven',
      client_city
    ),    
  ) |>
  # NORTH Cluster
  dplyr::mutate(
    # Convert 'n richland hills' with ZIP of 76118 to 'richland hills'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'n richland hills' & client_zip_code =='76118'),
      'richland hills',
      client_city
    ),    
    # convert 'north richard hills' with ZIP of 76187 to 76182
    client_zip_code = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'north richard hills' & client_zip_code == 76187),
      '76182',
      client_zip_code
    ),    
    # Consolidate version of 'north richland hills
    client_city = ifelse(
      case_id %in% checking$case_id &
        (client_city %in% c(
          'n richlnd hls', 'north richard hills', 'north richland hills', 'n richland hills'
        )),
      'north richland hills',
      client_city
    ),
    # convert 'north stone mountain' to 'stone mountain'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'north stone mountain',
      'stone mountain',
      client_city
    )
  ) |>
  # FORT Cluster
  dplyr::mutate(
    # convert 'fort blvd' to 'port bolivar'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fort blvd',
      'port bolivar',
      client_city
    ),    
    # convert 'forthancock' to 'fort hancock'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'forthancock',
      'fort hancock',
      client_city
    ),    
    # convert 'fort mc kavett' to 'fortt mckavett'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fort mc kavett',
      'fort mckavett',
      client_city
    ),    
    # 'fort worth' + ZIP 76180 + street address that DOES NOT include
    # 'riverview', 'manor', 'deaver', 'susan', or 'green castle'
    # to 'north richland hills'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'fort worth' & client_zip_code == '76180' &
           !stringr::str_detect(
             client_street_address, 
             "((green castle)|(riverview)|(deaver)|(manor)|(susan))")),
      'north richland hills',
      client_city
    ),        
    # 'fort worth' + ZIP 76182 + street address that DOES NOT include 'buck'
    # to 'north richland hills'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'fort worth' & client_zip_code == '76182' &
           !stringr::str_detect(
             client_street_address, 
             "(buck)")),
      'north richland hills',
      client_city
    ),   
    # convert 'fort fort' to 'fort worth'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fort fort',
      'fort worth',
      client_city
    ),    
    # convert 'fortworth' to 'fort worth'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fortworth',
      'fort worth',
      client_city
    ),    
    # convert 'forth worth' to 'fort worth'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'forth worth',
      'fort worth',
      client_city
    )
  ) |>
  # MOUNT Cluster
  dplyr::mutate(
    # convert 'mount pleasent' to 'mount pleasant'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'mount pleasent',
      'mount pleasant',
      client_city
    ),
    # convert 'mount vernont' to 'mount vernon'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'mount vernont',
      'mount vernon',
      client_city
    )
  )|>
  # POINT/PORT Cluster
  dplyr::mutate(
    # convert 'pointe' to 'point'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'pointe',
      'point',
      client_city
    ),
    # convert 'point blank' to 'pointblank'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'point blank',
      'pointblank',
      client_city
    ),
    # convert 'port boliver' to 'port bolivar'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'port boliver',
      'port bolivar',
      client_city
    ),
    # convert 'port isable' to 'port isabel'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'port isable',
      'port isabel',
      client_city
    ),
    # convert 'port lacaca' to 'port lavaca'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'port lacaca',
      'port lavaca',
      client_city
    ),
    # consolidate 'port atrthor', 'port autrthor', and 'port acres'
    # into 'port arthur'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city %in% c(
          'port atrthor', 'port autthor', 'port acres'
          ),
      'port arthur',
      client_city
    ),
    # consolidate 'port o connor' and 'port oconnor' into 
    # "port o'connor"
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city %in% c(
          'port oconnor', 'port o connor'
          ),
      "port o'connor",
      client_city
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("City:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; City:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We then made more systematic modifications. These modifications aimed to minimize variance in string distances, while maintaining important distance values.
-   Cardinal direction prefixes to city names were converted to a single letter abbreviation

    -   Cardinal directions only appeared as single word values (such as 'south', but not 'southeast')
    
-   'Mt' would be expanded to 'Mount'
-   'Ft' prefixes would be expanded to 'Fort'
-   No modifications would be made to "Point" or "Port" prefixes, as no occurences of abbreviations were found to currently exist (and the words themselves are fairly short)

```{r}
aps <- aps |>
  dplyr::mutate(
    # cardinal directions
    client_city = ifelse(
      stringr::str_detect(client_city, '^(east )'),
      stringr::str_replace(client_city, '^(east )', 'e '),
      client_city
    ),  
    client_city = ifelse(
      stringr::str_detect(client_city, '^(west )'),
      stringr::str_replace(client_city, '^(west )', 'w '),
      client_city
    ),  
    client_city = ifelse(
      stringr::str_detect(client_city, '^(north )'),
      stringr::str_replace(client_city, '^(north )', 'n '),
      client_city
    ),  
    client_city = ifelse(
      stringr::str_detect(client_city, '^(south )'),
      stringr::str_replace(client_city, '^(south )', 's '),
      client_city
    ),  
    # 'mt' to 'mount'
    client_city = ifelse(
      stringr::str_detect(client_city, '^(mt)'),
      stringr::str_replace(client_city, '^(mt)', 'mount'),
      client_city
    ),
    # 'ft' to 'fort'
    client_city = ifelse(
      stringr::str_detect(client_city, '^(ft)'),
      stringr::str_replace(client_city, '^(ft)', 'fort'),
      client_city
    )
    
  ) 
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(target_regex)
rm(checking)
```


### Street Addresses

#### PO BOX Entries

Previous iterations of similar tasks and exploration of the existing data have revealed multiple PO BOX addresses within the data. While these may be valid mailing addresses, they are not typically helpful for fuzzy matching. We utilized regular expressions to attempt to isolate potential PO BOX values for manual review.We isolated these 1,531 observations for manual review.

```{r}
target_regex <- c(
  paste0(
      "^(po box|po  box|p\\.o\\. box|p\\.o box|pobox|",
      "p\\. o\\. box| p\\. o box|p o box|box|po|p\\.o|",
      "p\\. o\\.|p o|p\\.o\\.)"
    ),
    paste0(
      "\\s(po box|po  box|p\\.o\\. box|p\\.o box|pobox|",
      "p\\. o\\. box|p\\. o box|p o box|box|po|p\\.o|p\\. o\\.|",
      "p o|p\\.o\\.)$")
    )

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_street_address, target_regex[1]) |
      stringr::str_detect(client_street_address, target_regex[2])
    )

nrow(checking)
# [1] 1513
```

We identified that the variations that contained actual PO Boxes were prefixed with "po box", "p o box", "p.o. box", or "pob". One address was found to be valid and not a PO BOX (matched by the word 'box' in the street name), and another was a foreign address (matched due to 'po' at start of street name). 

One street name required a point fix as it gave a county road address as "box # county road #". The original address value was shifted to the client notes, and the address was otherwise standardized to "# cr #" format.

All of the remaining PO BOX addresses were standardized to strip the "po box" prefixes, and isolate the remaining value into a new field: 'client_pobox'

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_
  ) |>
  dplyr::mutate(
    # Catch the "box # county road #" address and standardize
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(
          client_street_address, 
          '([0-9]+) county road ([0-9]+)$'),
      client_street_address,
      client_msc
      ),
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(
          client_street_address, 
          '([0-9]+) county road ([0-9]+)$'),
      paste(
        str_match(client_street_address,'([0-9]+) county road ([0-9]+)$')[,2],
        'cr', 
        str_match(client_street_address,'([0-9]+) county road ([0-9]+)$')[,3]
        ),
      client_street_address
      ),
    # Catch and standardize remaining actual PO BOX values into 'client_pobox'
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(
          client_street_address, 
          '^(p\\.o\\. box)|(p o box)|(po box)|(pob )'),
      client_street_address,
      client_msc
    ),
    client_pobox = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(
          client_street_address, 
          '^(p\\.o\\. box)|(p o box)|(po box)|(pob )'),
      stringr::str_match(
        client_street_address,
        '^((p\\.o\\. box)|(p o box)|(po box)|(pob ))[ \\-,\\.#]*(.+)')[,7],
      client_pobox
      ),
    client_street_address = ifelse(
      !is.na(client_pobox) |
        stringr::str_detect(
          client_street_address, 
          '^(p\\.o\\. box)|(p o box)|(po box)|(pob )'),
      NA_character_,
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Unknown and Equivalents

Previous iterations of similar tasks and exploration of the existing data have revealed multiple potential values which would indicate a missing, unknown, or otherwise omitted entry for street address. We utilized regular expressions to attempt to isolate potential instances of these values for manual review.

We isolated 343 observations which potentially contained any match to our suspected "unknown" equivalent content.

```{r}
target_regex <- c(
    paste0(
      "(unknown|unknow|unk|unable to obtain|unable to attain|putp|",
      "decl|refused|ref|n/a|none|declined|unable|residence|xxx)"
      ),
    "^([a-z])$",
    "^([0-9])*$",
    "^(pt|subj)"
)

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_street_address, target_regex[1])|
      stringr::str_detect(client_street_address, target_regex[2])|
      stringr::str_detect(client_street_address, target_regex[3])|
      stringr::str_detect(client_street_address, target_regex[4])
  )

nrow (checking)
# [1] 344
```

Many of these appeared to be valid entries, so subsets based on each of our regular expressions were examined for more precise review.

We isolated the 327 entries that matched our first regular expression.

```{r}
checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_street_address, target_regex[1])
  )

nrow (checking)
# [1] 327
```

All entries in this set which contained digits appeared to be potentially valid street addresses. The 18 rows with values without numbers were further isolated for review.

```{r}
checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_street_address, target_regex[1]) &
      !stringr::str_detect(client_street_address, '([0-9]+)')
  )

nrow (checking)
# [1] 18
```

All of these values appear to be equivalent to "unknown" with the exception of a single entry with a value of "fairefield hotel". Unfortunately, this entry is in a major metropolitan area with multiple Fairfield hotels, so no replacement of the business name with an address was possible at this time. That value was shifted into the notes column, and all street addresses in this cluster were shifted to missing values.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  # Shift single observation for 'fairefield hotel' to notes
  dplyr::mutate(
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        client_street_address == 'fairefield hotel',
      client_street_address,
      client_msc
    ),
  # ALSO add to client_street_address_name
    client_street_address_name = ifelse(
      case_id %in% checking$case_id & 
        client_street_address == 'fairefield hotel',
      client_street_address,
      client_street_address_name
    )
  )|>
  dplyr::mutate(
  # Convert all matching values to missing values
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      NA_character_,
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

There were no entries that matched our second regular expression.

```{r}
checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_street_address, target_regex[2])
  )

nrow (checking)
# [1] 0
```

We isolated the 16 entries that matched our third regular expression.

```{r}
checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_street_address, target_regex[3])
  )

nrow (checking)
# [1] 16
```

As all of these values only had text, we shifted the values to the notes field, and otherwise converted street address to an missing value.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  # Shift values into notes field
  dplyr::mutate(
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    )
  )|>
  dplyr::mutate(
  # Convert all matching values to missing values
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      NA_character_,
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We isolated the 1 entry that matched our fourth regular expression.

```{r}
checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_street_address, target_regex[4])
  )

nrow (checking)
# [1] 1
```

This entry had a street address of 'subjective personal care home' in a major metropolitan area. There was no way to substitute or otherwise resolve this address, so we shifted the value to the notes field and otherwise removed the value.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  # Shift values into notes field
  dplyr::mutate(
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    )
  )|>
  dplyr::mutate(
  # Convert all matching values to missing values
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      NA_character_,
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We purged our checking subset and target regular expressions for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Non-Standard Characters (non letter, non number, non-white space)

We then turned towards cleaning any unanticipated special characters (anything other than a letter, number, or white space). As there were 3,638 rows with these characters, we proceeded to use targetted subsets in cleaning to ensure manageable sizes in manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([^a-z0-9 ])')
  )

nrow(checking)
# [1] 3638
```

##### Commas

We identified a comma as a high-priority component of a street address which might indicate a non-valid component within the street address field. We isolated the 150 observations that contained a comma in the street address field for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(,)')
  )

nrow(checking)
# [1] 150
```

We refined this set by eliminating any commas that were at the end of a street address value, with no text after the comma. This reduced our set to 116 matches.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(,)$'),
      stringr::str_remove_all(client_street_address, '(,)$'),
      client_street_address
    )
  )

checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(,)')
  )

nrow(checking)
# [1] 116
```

These observations were manually divided into 4 groups for further assessment and point-fixes:
-   Addresses which appeared to have different portions of the address which had designated fields (city, state, zip, etc.) within the street address field (29 rows)
-   Addresses which appeared to have commas and/or hyphens in the "street number" portion of the street address field (6 rows)
-   Addresses which appeared to have business names for the street address with a secondary address (Room or apartment number) separated by the comma (2 rows)
-   Addresses which appeared to have overall questionable street addresses (more than one street name, odd numerical format, etc.) (13 rows)

###### Different Address Portions in Street Address

We identified several entries which had additional values for city, state, and/or zip code within the street address field. For the vast majority of these entries, the other fields already contained the relevant data. There were three particular entries which required additional fixes or notes: one entry with 'vicc' indicating it was part of the Valley International Country Club (moved to notes), and two entries (one for New Braunfels and one for Converse) that had cities of "San Antonio" (while those cities are in the San Antonio metro area, the proper city was updated). 

We were able to use a single regular expression for most of our city fixes, but we did require additional regular expressions for values indicating 'Houston', 'Irving', and 'Detroit'.

This fix impacted 29 rows.

```{r}
target_regex <- paste0(
  '(.+?)(?:,*?)( crowley| springto| humb| fort worth| odessa| san|',
  ' converse| new braunfels| vicc| alamo)'
  )
  
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  # First, update 'point fixes' in fields other than street address
  dplyr::mutate(
  # Shift 'VCC' to notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(.+?)(?:,*?)( vicc)'),
      'Valley International Country Club (VICC)',
      client_msc
    ),
  # Update CITY for 'converse' catch
    client_city = ifelse(
      case_id %in% checking$case_id &
        client_city == 'san antonio' &
        stringr::str_detect(
          client_street_address, 
          '(.+?)(?:,*?)( converse)'),
      'converse',
      client_city
    ),
  # Update CITY for 'new braunfels' catch
    client_city = ifelse(
      case_id %in% checking$case_id &
        client_city == 'san antonio' &
        stringr::str_detect(
          client_street_address, 
          '(.+?)(?:,*?)( new braunfels)'),
      'new braunfels',
      client_city
    )
  ) |>
  dplyr::mutate(
  # Remove values for cities in target regex from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, target_regex),
      stringr::str_match(client_street_address, target_regex)[,2],
      client_street_address
    ),
  # Remove values for city of 'houston' from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(.+?)(, houston, texas|, houston| houston|houston, texas)$'
          ),
      stringr::str_match(
        client_street_address, 
        '(.+?)(, houston, texas|, houston| houston|houston, texas)$'
        )[,2],
      client_street_address
    ),
  # Remove values for city of 'detroit' from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(.+?)(?:,*?)( detroit, mi)(.+?)'
          ),
      stringr::str_match(
        client_street_address, 
        '(.+?)(?:,*?)( detroit, mi)(.+?)'
        )[,2],
      client_street_address
    ),
  # Remove values for city of 'irving' from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(.+?)(?:,*?)( irving, tx)(.+)'
          ),
      stringr::str_match(
        client_street_address, 
        '(.+?)(?:,*?)( irving, tx)(.+)'
        )[,2],
      client_street_address
    ),
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We further narrowed our manual verification subset, so that it only included values that continued to have commas in the street address field. The 87 remaining observations were successfully isolated, and are addressed in following sections.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(,)')
  )

nrow(checking)
# [1] 87
```

###### Comma/Hyphen in "Street Number" Portion of Street Address

We next focused on the six entries which appeared to have more than one numerical value within the "street number" (leading) portion of the street address. 

Of these, there was one address value (present in two rows) which had street number values separated by a hyphen. Neither component in isolation appeared to be a valid match within the city, state, and/or ZIP Code associated with these values. As such, the street address value for these observations was moved to the notes field and otherwise cleared.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
  # Shift value to notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address,
          '^([0-9]+?)[-]+(?: )*([0-9]+.)'
          ),
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Remove value from field
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address,
          '^([0-9]+?)[-]+(?: )*([0-9]+.)'
          ),
      NA_character_,
      client_street_address
    )    
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

The remaining four entries appeared to follow an alternative addressing standard, which is approved by [USPS standards](https://pe.usps.com/text/pub28/28c2_003.htm): placing the secondary address (apartment, unit number, etc.) before the primary street address, and separating with a comma. As such, we separated these values for clarity, and put the original address in the notes field (in case they proved useful in fuzzy match comparison).

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
  # Shift address value to notes field
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address,
          '^([0-9]+?)(?:,)+(?: )*([0-9]+.+)'
          ),
      client_street_address,
      client_msc
    ),
  # Shift first numerical value to client_street_address_scnd1_val
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address,
          '^([0-9]+?)(?:,)+(?: )*([0-9]+.+)'
          ),
      stringr::str_match(
          client_street_address,
          '^([0-9]+?)(?:,)+(?: )*([0-9]+.+)'
          )[,2],
      client_street_address_scnd1_val
    ),
  # Trim remainder of street address to omit the previously shifted component
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address,
          '^([0-9]+?)(?:,)+(?: )*([0-9]+.+)'
          ),
      stringr::str_match(
          client_street_address,
          '^([0-9]+?)(?:,)+(?: )*([0-9]+.+)'
          )[,3],
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```


###### Business Name Only with Secondary Address Portion

There were two observations that appeared to have a business name followed by a secondary address field (unit, apartment, etc.). Luckily, both of those building names were identifiable to a single location within the city, state, and zip provided. As such, we shifted the business name to the "client_street_address_name" field, secondary addressing to "client_street_address_scnd1_type" and "client_street_address_scnd1_val" as appropriate, and updated the street addresses.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  dplyr::mutate(
    # Copy original values to notes, so that they are not lost
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '( room|apts)'),
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # ROOM NUMBER
    client_street_address_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', room ([0-9]+)'),
      stringr::str_match(client_street_address, '^(.+), room [0-9]+')[,2],
      client_street_address_name
    ),
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', room ([0-9]+)'),
      'rm',
      client_street_address_scnd1_type
    ),
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', room ([0-9]+)'),
      stringr::str_match(client_street_address, ', room ([0-9]+)')[,2],
      client_street_address_scnd1_val
    ),
  # APARTMENT BY COMPLEX NAME
    client_street_address_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'apts'),
      stringr::str_match(client_street_address, '(.+ apts),')[,2],
      client_street_address_name
    ),
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'apts'),
      'apt',
      client_street_address_scnd1_type
    ),
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'apts'),
      stringr::str_match(client_street_address, 'apts, apt ([0-9]+)')[,2],
      client_street_address_scnd1_val
    )
  ) |>
  dplyr::mutate(
    # REPLACE THE STREET ADDRESSES WITH FOUND VALUES
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', room ([0-9]+)'),
      '150 alford dr',
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'apts'),
      '10700 fuqua st',
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
        ifelse(!is.na(client_msc),
          paste("Street Addr:", client_msc),
          client_notes
          ),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```


###### Otherwise Questionable Format and/or Values for Street Address

There were 13 rows with street address values that otherwise continued to remain questionable, but did not fit into the prior categories. Many of these were found to have unusual street names (such as a highway with a letter at the end of the numerical designation, but separated erroneously by a comma), name the type of street (private road, etc), or were otherwise unusual. There was also an entry with an alternative street name (in a rural area) - we did not modify that value in this pass, but did copy the existing street name value to the notes column.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |>
  # Secondary Components
  dplyr::mutate(
    # Complex address with an apartment suffix
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address,'n mi'),
      stringr::str_match(client_street_address, 'apt ([0-9]+)')[,2],
      client_street_address_scnd1_val
      ),
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address,'n mi'),
      'apt',
      client_street_address_scnd1_type
      )
  ) |>
  # Shifting address values to notes
  dplyr::mutate(
    # Complex address with an apartment suffix
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address,'n mi'),
      client_street_address,
      client_msc
      ),
    # "Alternative name" for road
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', cr'),
      client_street_address,
      client_msc
    ),
    # Letter suffix for numerical street
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', r$'),
      client_street_address,
      client_msc
    ),
    # Specified road type
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'private road'),
     'private road',
     client_msc
    ),
    # Street number misplaced to end of address
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, '^(highway [0-9])'),
      client_street_address,
      client_msc
    )
  ) |>
  # Adjusting components
  dplyr::mutate(
     # Complex address with an apartment suffix
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address,'n mi'),
      paste(
        stringr::str_match(
          client_street_address,
          '([0-9]+) n mi ([0-9 /]+) w'
          )[,2], 
        'n mile', 
        stringr::str_replace(
          stringr::str_match(
            client_street_address,
            '([0-9]+) n mi ([0-9 /]+) w'
            )[,3], 
          ' ', 
          '-'
          ), 
        'w rd'
        ),
      client_street_address
      ),
    # Letter suffix for numerical street
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', r$'),
      paste0(
        stringr::str_match(client_street_address, '^(.+), (.+)$')[,2],
        stringr::str_match(client_street_address, '^(.+), (.+)$')[,3]
        ),
      client_street_address
    ),
    # Specified road type
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'private road'),
     stringr::str_match(client_street_address, ',(.+)$')[,2],
     client_street_address
    ),
    # Street number misplaced to end of address
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, '^(highway [0-9])'),
     paste(
       stringr::str_match(
         client_street_address, 
         '^(?:highway )([0-9]+[a-z]+), (?:.*?)([0-9]+)'
         )[,3], 
       'hwy', 
       stringr::str_match(
         client_street_address, 
         '^(?:highway )([0-9]+[a-z]+), (?:.*?)([0-9]+)'
         )[,2]
       ),
     client_street_address
    ),    
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
        ifelse(!is.na(client_msc),
          paste("Street Addr:", client_msc),
          client_notes
          ),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))

modified_set <- aps |> 
  filter(
    case_id %in% checking$case_id & 
      stringr::str_detect(client_street_address, ', cr')
    )
```

We then processed this alternative name as a new row, and ensured both addresses appeared in the data set as two separate rows.

```{r}
# Modify new row to take the alternative value
modified_set <- modified_set |>
  dplyr::mutate(
  # "Alternative name" for road
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, ', cr'),
        stringr::str_remove(
          stringr::str_replace(
            client_street_address,
            stringr::str_match(
              client_street_address, 
              '^([0-9]+) (.+), (.+)'
              )[,3],
            stringr::str_match(
              client_street_address, 
              '^([0-9]+) (.+), (.+)'
              )[,4]
            ),
          ',(.+)$'
        ),
      client_street_address
    )
  )

# Modify the original row to only have the main value
aps <- aps |>
  dplyr::mutate(
    client_street_address = ifelse(
      case_id %in% modified_set$case_id,
      stringr::str_remove(client_street_address, ',(.+)$'),
      client_street_address
    )
  )

# Add new row to data set
aps <- dplyr::bind_rows(aps, modified_set)
```


We further narrowed our manual verification subset, so that it only included values that continued to have commas in the street address field. The 66 remaining observations were successfully isolated.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(,)')
  )

nrow(checking)
# [1] 66
```

###### Secondary Address Components

We excluded the entries where we had previously identified an address that was likely outside of the USA. We isolated the remaining 55 observations for manual review. All appeared to reference secondary address components (apartment, lot, unit, etc.)

```{r}
checking <- checking |> 
  filter(is.na(client_country))

nrow(checking)
# 55
```
We identified components for apartment, unit, building, trailer, room, lot, suite and space. We extracted these values, and removed those components from the street address field.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  # Shift values into notes field
  dplyr::mutate(
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
      )
  ) |>
  # Shift value to client_street_address_scnd1_val
  dplyr::mutate(
    # Apartment
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:apt|apartment|aprt)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'apt',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:apt|apartment|aprt)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:apt|apartment|aprt)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
    # Unit
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:unit)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'unit',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:unit)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:unit)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
    # Building
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:building|blg|bldg)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'bldg',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:building|blg|bldg)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:building|blg|bldg)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
    # Trailer
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:trlr|trailer|trl|tr)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'trlr',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:trlr|trailer|trl|tr)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:trlr|trailer|trl|tr)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
    # ROOM
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:room|rm)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'rm',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:room|rm)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:room|rm)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
    # Lot
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:[^sp]lot)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'lot',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:[^sp]lot)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:[^sp]lot)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
    # Suite
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:suite|ste)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'ste',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:suite|ste)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:suite|ste)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
    # Space
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:space|spc)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      'spc',
      client_street_address_scnd1_type
    ),
      client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:space|spc)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_match(client_street_address,
          '((?:space|spc)(?:[ ,\\.#]+?)([^,#]+))'
          )[,3],
      client_street_address_scnd1_val
    ),
  ) |>
  # Remove shifted portion from Street Address
  dplyr::mutate(
    # Apartment
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:apt|apartment|aprt)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:apt|apartment|aprt)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    ),
    # Unit
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:unit)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:unit)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    ),
    # Building
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:building|blg|bldg)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:building|blg|bldg)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    ),
    # Trailer
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:trlr|trailer|trl|tr)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:trlr|trailer|trl|tr)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    ),
    # Room
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:room|rm)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:room|rm)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    ),
    # Lot
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:[^sp]lot)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:[^sp]lot)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    ),
    # Suite
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:suite|ste)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:suite|ste)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    ),
    # Space
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:space|spc)(?:[ ,\\.#]+?)([^,#]+))'
          ),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(
          client_street_address, 
          '((?:space|spc)(?:[ ,\\.#]+?)([^,#]+))'
          )[,1]
        ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc)) 
```

There were 11 remaining rows which indicated values that either did not have a unit classifier, or the unit classifier was not USPS valid (duplex, number, etc.). We shifted the values of "duplex", "slot", and "plot" to our notes column, and otherwise shifted and scrubbed these values.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  # Notes & Unit # Values
  dplyr::mutate(
    # Duplex in notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_val) &
        str_detect(client_street_address, 'duplex'),
      'duplex',
      client_msc
    ),
    # Slot in notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_val) &
        str_detect(client_street_address, 'slot'),
      'slot',
      client_msc
    ),
    # Plot in notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_val) &
        str_detect(client_street_address, 'plot'),
      'plot',
      client_msc
    ),
    # Unit value for PLOT, SLOT, NUMBER, DUPLEX values
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:duplex|number|plot|slot)(?:[ ,\\.#]+)([^,#]+?))$'
          ),
      stringr::str_match(client_street_address,
          '((?:duplex|number|plot|slot)(?:[ ,\\.#]+)([^,#]+?))$'
          )[,3],
      # Otherwise, try to match alternative expression
      ifelse(
        case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '((?:[ ,\\.#]+)([^,#]+?))$'
          ),
        stringr::str_match(client_street_address,
          '((?:[ ,\\.#]+)([^,#]+?))$'
          )[,3],
      client_street_address_scnd1_val
      )
    )
  ) |>
  # Removed shifted values
    dplyr::mutate(
    #PLOT, SLOT, NUMBER, DUPLEX values
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_type) &
        stringr::str_detect(
          client_street_address, 
          '((?:duplex|number|plot|slot)(?:[ ,\\.#]+)([^,#]+?))$'
          ),
      stringr::str_remove(
        client_street_address,
        stringr::str_match(
          client_street_address,
          '((?:duplex|number|plot|slot)(?:[ ,\\.#]+)([^,#]+?))$'
          )[,1]
        ),
      # Otherwise, try to match alternative expression
      ifelse(
        case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_type) &
        stringr::str_detect(
          client_street_address, 
          '((?:[ ,\\.#]+)([^\\(\\),#]+?))$'
          ),
        stringr::str_remove(
          client_street_address,
          stringr::str_match(
            client_street_address, 
            '((?:[ ,\\.#]+)([^\\(\\),#]+?))$'
            )[,1]
          ),
      client_street_address
      )
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc)) 
```

We then removed all remaining commas from potentially USA-based entries, standardized white spaces, and trimmed leading or trailing white spaces.

```{r}
aps <- aps |> 
  dplyr::mutate(
    client_street_address = ifelse(
      is.na(client_country),
      stringr::str_replace(client_street_address, ',',''),
      client_street_address
      )
  ) |>
  dplyr::mutate(
    client_street_address = stringr::str_replace(
      client_street_address, 
      '( ){2,}', ' '
      )
  ) |>
  dplyr::mutate(
    client_street_address = stringr::str_trim(client_street_address)
  )
```

We purged our target regular expression, checking subset, and modified value subset for memory management.

```{r}
rm(checking)
rm(target_regex)
rm(modified_set)
```

##### Parentheses

In prior cleaning and standardization, we found parentheses in several fields (which impacted regular expression use). Parentheses were thus identified as a high-priority component of a street address which might indicate a non-valid component within the street address field. We isolated the 12 observations that contained a parenthesis in the street address field for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([(|)])')
  )

nrow(checking)
# [1] 12
```

###### Comments, Clarifiers

There was a single row which only had a comment found in the street address field. This was shifted to our notes column.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Comment value only - shift to notes and remove
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, "this morning"),
      client_street_address,
      client_msc
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, "this morning"),
      NA_character_,
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We additionally shifted two parenthetical values which only contained clarifying information, while retaining the remaining street address information. We also caught a parenthetical that referred to a unit (secondary address) and a location name.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Comment in parentheses to NOTES
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(\\((bus|new).+\\))'),
      stringr::str_match(client_street_address, '(\\((bus|new).+\\))')[,2],
      client_msc
    ),
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(\\((back| b).+\\))'),
      client_street_address,
      client_msc
    ),
    # Secondary Address Value Shift
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(\\((back).+\\))'),
      'REAR',
      client_street_address_scnd1_val
    ),
    # Location name value shift
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(\\(( b).+\\))'),
      paste(
        stringr::str_match(
          client_street_address, 
          '(?:\\()(( b).+)(?:\\))'
          )[,2], 
        " retirement community"
        ),
      client_street_address_name
    ),
    # Remove shifted values from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(
          client_street_address, 
          '(\\((back|bus|new| br).+\\))'
          ),
      # NOTE: This has to be built like this, rather
      # than a "paste0" operation, or it throws errors
      # last confirmed true 2024-05-23
      stringr::str_remove(
        client_street_address,
        stringr::str_replace(
          stringr::str_replace(
              stringr::str_match(
                client_street_address,
                '(\\((back|bus|new| br).+\\))'
                )[,2],
              '\\)',
              '\\\\)'
              ),
        '\\(',
        '\\\\('
        )
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

###### Alternative names or values for Street Number and/or Name

The remaining values would require a duplication of their row with modification of the street address value (as two street addresses were indicated in one row). First, we copied all such values into the notes field so it would be persistent on the duplicated row. We then isolated a subset of these rows (where we would create our modification, then append to our data set) and deleted the parenthetical items from our data set.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(\\(|\\))'),
    client_street_address,
    client_msc
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))

# Copy the rows to create 'modified duplicates' of before fixing.
modified_set <- aps |> 
  filter(stringr::str_detect(client_street_address, '(\\(|\\))'))

aps <- aps |>
  dplyr::mutate(
    # Removing parentheses from street address values
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(
          client_street_address, 
          '(\\(.+\\))'
          ),
      # NOTE: This has to be built like this, rather
      # than a "paste0" operation, or it throws errors
      # last confirmed true 2024-05-23
      stringr::str_remove(
        client_street_address,
        stringr::str_replace(
          stringr::str_replace(
              stringr::str_match(
                client_street_address,
                '(\\(.+\\))'
                )[,2],
              '\\)',
              '\\\\)'
              ),
        '\\(',
        '\\\\('
        )
      ),
      client_street_address
    )
  )
```

We processed these "alternative" value rows, and added them to our data set.

```{r}
modified_set <- modified_set |>
  dplyr::mutate(
    # Street Number, has "and" prefixing in the parentheses
    client_street_address = ifelse(
      stringr::str_detect(
        client_street_address, 
        '(?:\\(and )([0-9]+)(?:\\))'),
      stringr::str_replace(
        client_street_address,
        stringr::str_match(
          client_street_address,
          '^([0-9]+)(.+)(?:\\()'
          )[,2],
        stringr::str_match(
          client_street_address, 
          '(?:\\(and )([0-9]+)(?:\\))'
          )[,2]
      ),
      client_street_address
    ),
    # Street Names, (no 'and' in the parentheses, located at the end of entry)
    client_street_address = ifelse(
      stringr::str_detect(
        client_street_address, 
        '^(([0-9]+)(?: +)([^\\(]+)(?: +)(?:\\())'
        ),
      stringr::str_replace(
        client_street_address,
        stringr::str_match(
          client_street_address,
          '^(([0-9]+)(?: +)([^\\(]+)(?: +)(?:\\())'
          )[,4],
        stringr::str_match(client_street_address, '\\(((.+))\\)')[,2]
      ),
      client_street_address
    ),
    # Removing parentheses and their values
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(
          client_street_address, 
          '(\\(.+\\))'
          ),
      # NOTE: This has to be built like this, rather
      # than a "paste0" operation, or it throws errors
      # last confirmed true 2024-05-23
      stringr::str_remove(
        client_street_address,
        stringr::str_replace(
          stringr::str_replace(
              stringr::str_match(
                client_street_address,
                '(\\(.+\\))'
                )[,2],
              '\\)',
              '\\\\)'
              ),
        '\\(',
        '\\\\('
        )
      ),
      client_street_address
    )
  )

# Add new rows to our data set
aps <- dplyr::bind_rows(aps, modified_set)
```

We purged our checking subset and modified values subset for memory management.

```{r}
rm(checking)
rm(modified_set)
```

##### Hyphens

In prior cleaning and standardization, we found hyphens in street address values. We isolated the 1,403 observations that contained a hyphen in the street address field for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(-)')
  )

nrow(checking)
# [1] 467
```

###### Hyphen after initial numeric sequence

We refined our subset for examination by isolating the 62 rows that had a hyphen directly after the initial numeric street number value, with or without a white space separator.

```{r}
checking <- aps  |>
  filter(
    stringr::str_detect(client_street_address, '^([0-9 ]+-)')
  )

nrow(checking)
# [1] 62
```

There was one address (across 9 case ID values) which appeared to be invalid. We shifted this value to our notes field, and converted the street address field for that value into a missing (`NA`) value. One row was a valid 1/2 lot address. Four entries were valid with removal of the hyphen (one with the hyphen in the street number, two with a hyphen between street number and street name, and one with a hyphen connecting street number and name but an inappropriate white space in street name). Two addresses appeared to reference block ranges, so street address was snipped to only include the beginning of the block range. Otherwise, values after the hyphen appeared to indicate unit numbers, and were shifted accordingly.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Shift all original values to notes field
    # excluding the international address
    client_msc = ifelse(
      case_id %in% checking$case_id & is.na(client_country),
      client_street_address,
      client_msc
    ),
    # Point-adjust street address values
    client_street_address = ifelse(
      case_id %in% checking$case_id & is.na(client_country),
      dplyr::case_when(
        # Remove the unresolvable entry
        stringr::str_detect(client_street_address, 'u.s. 84') ~ 
          NA_character_,
        # Remove hyphen from one address
        stringr::str_detect(client_street_address, ' moku ') ~ 
          stringr::str_remove(client_street_address, '-'),
        # Keep only first portion of block-range values
        stringr::str_detect(client_street_address, '-198 fm') ~
          stringr::str_remove(client_street_address, '-198'),
        stringr::str_detect(client_street_address, '730 helm') ~
          stringr::str_remove(client_street_address, '-730'),
        # Fixing 'HCR' entry
        stringr::str_detect(client_street_address, '-h cr') ~
          stringr::str_replace(client_street_address, '(-h cr)', ' hcr'),
        # Fixing inappropriate hyphens (FM entry)
        stringr::str_detect(client_street_address, '1-54th') ~ 
          stringr::str_replace(client_street_address, '-', ' '),
        # Fixing inappropriate hyphens (TX HWY entry)
        stringr::str_detect(client_street_address, '00(-tx )') ~
          stringr::str_replace(client_street_address, '-tx', ' tx hwy'),
        TRUE ~ client_street_address,
        ),
      client_street_address
      )
  ) |>
  dplyr::mutate(
    # Shift remaining post-hyphen unit-number values to appropriate variable
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id & is.na(client_country) &
        stringr::str_detect(
          client_street_address, 
          '([0-9a-z]+)([ ]{0,1}-[ ]{0,1}(?!1/2)([0-9a-z]+))'),
      stringr::str_match(
        client_street_address,
        '([0-9a-z]+)([ ]{0,1}-[ ]{0,1}(?!1/2)([0-9a-z]+))'
        )[,4],
      client_street_address_scnd1_val
    ),
    # Remove the unit number portion from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id & is.na(client_country) &
        stringr::str_detect(
          client_street_address, 
          '([0-9a-z]+)([ ]{0,1}-[ ]{0,1}(?!1/2)([0-9a-z]+))'
          ),
        stringr::str_remove(
          client_street_address,
          stringr::str_match(
          client_street_address,
          '([0-9a-z]+)([ ]{0,1}-[ ]{0,1}(?!1/2)([0-9a-z]+))'
          )[,3]
      ),
      client_street_address
    ), 
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

###### Hyphens with white space before or after

We isolated the 19 observations that contained a hyphen with a leading or trailing white space in the street address field.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(- | -)')
  )

nrow(checking)
# [1] 19
```

There were two addresses which actually referenced intersections, and were not resolvable. We shifted these values to our notes field, and otherwise removed them from the street address field. We additionally had one street address which included a unit number, and another that included a business name. 

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy un-resolvable entries and unit number address into notes field
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address,
          '(ave. - high|street - rada|road - a|ia - sweet)'),
      client_street_address,
      client_msc
    )
  ) |>
dplyr::mutate(
    # Shift unit number
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'road - a'),
      'a',
      client_street_address_scnd1_val
    ),
    # Shift business name
    client_street_address_name = ifelse(
      stringr::str_detect(
          client_street_address,
          '(ia - sweet)'),
      paste0(stringr::str_match(
        client_street_address, 
        '^(.+?) - (.+?)$'
        )[,3], 
        'n'),
      client_street_address_name
    ),
    # Remove un-resolvable entries
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address,
          '(ave. - high|street - rada)'),
      NA_character_,
      client_street_address
    ),
  
    # Point-fix entries
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        # Remove '- hwy' from 'us- hwy' entry
        stringr::str_detect(client_street_address, 'us- hwy') ~
          stringr::str_remove(client_street_address, '- hwy'),
        # Rename 'texas -3' entry to 'tx hwy 3'
        stringr::str_detect(client_street_address, 'texas -3') ~
          stringr::str_replace(client_street_address, 'texas -3', 'tx hwy 3'),
        # Remove business name from address
        stringr::str_detect(client_street_address, 'ia - sweet') ~ 
          stringr::str_match(
          client_street_address, 
          '^(.+?) - (.+?)$'
          )[,2],
        # Remove unit number from address
        stringr::str_detect(client_street_address, 'road - a') ~
          stringr::str_remove(client_street_address, '- a'),
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
    # remove collapse remaining white space around hyphens
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, '( -|- )'),
      stringr::str_replace(
        stringr::str_replace(client_street_address, '( {1,}-)','-'),
        '(- {1,})','-'
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc)) 
```

###### Hyphens with only numerals before and after

We isolated the 14 observations that contained a hyphen with leading and trailing numerals in the street address field.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([0-9]+-[0-9]+)')
  )

nrow(checking)
# [1] 14
```

We had one unresolvable entry (a street that appeared to either refer to a rural post box, or an entirely invalid location, but otherwise unclear based on present information). We had a county road with the street number appended at the end after a hyphen, which we moved to the start of the field. We also had a unit number separated by a hyphen. There were several values for highways that overlapped, which we converted to slashes for processing later in our cleaning process.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Shift un-resolvable entry to notes
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address,'9 box 26'),
      client_street_address,
      client_msc
    ),
    # Copy value from the unit number and disorganized street fields to notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(st unit|county rd\\.)'),
        client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Remove un-resolvable entry
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address,'9 box 26'),
      NA_character_,
      client_street_address
    ),
    # Capture unit number
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'unit'),
      stringr::str_match(client_street_address, '^(.+?) unit (.+?)$')[,3],
      client_street_address_scnd1_val
    ),
    # Remove unit number from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'unit'),
      stringr::str_match(client_street_address, '^(.+?) unit (.+?)$')[,2],
      client_street_address
    ),    
    # Shift street number from end of cr value to start
    client_street_address = ifelse(
        case_id %in% checking$case_id &
          stringr::str_detect(client_street_address, 'county rd.'),
        paste0(
          stringr::str_match(client_street_address, '([0-9]+)-([0-9]+)$')[,3],
          ' cr ',
          stringr::str_match(client_street_address, '([0-9]+)-([0-9]+)$')[,2]
      ),
      client_street_address
    ),
    # Convert highway/hwy hyphens into slashes
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(highway|hwy)'),
      stringr::str_replace(client_street_address, '-', '/'),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

###### Hyphens with only letters before and after

We isolated the 35 observations that contained a hyphen with leading and trailing letters in the street address field. All appeared to be valid.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([a-z]+-[a-z]+)')
  )

nrow(checking)
# [1] 35
```

###### All remaining Hyphens

We isolated the 388 observations that continued to contained a hyphen in the street address field. While the vast majority appeared to be valid, a few outlier entries were selected for further verification and manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(-)')
  )

nrow(checking)
# [1] 388
```

There was a single address that had two forms of the same street address in a single line (local name and state-wide name for the same street). While either street name was valid, the combination was not. To correct this, we isolated this entry to create a duplicate value row, which would contain one version of the street address.

```{r}
# Capture a value that has two potentially valid street addresses in a single
# address field (not valid in same line), and isolate one of the values
modified_set <- aps |>
  filter(
    case_id %in% checking$case_id &
      stringr::str_detect(client_street_address, 'n. pan am expy')
  ) |>
  dplyr::mutate(
    client_msc = client_street_address,
    client_street_address = stringr::str_match(
      client_street_address, 
      '^((.+?)(n. pan am expy ))(.+?)$'
      )[,2]
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc)) 
```

We then created further modifications. There was one address that could not be resolved (an intersection in a major city). One address had the cross street listed (which we removed). Others stated unit types and/or numbers, or business names. We then merged in the additional row for our modified set. All other hyphenated values appeared to be valid.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_msc = NA_character_
  ) |>
  dplyr::mutate(
    # Capture original addresses for unit number fixes, un-resolvable entry
    # any any other changes
    client_msc = ifelse(
      case_id %in% checking$case_id & (
        stringr::str_detect(
          client_street_address,
          '(apt| lot|#|room|king dr and i)'
          ) |
        stringr::str_detect(
          client_street_address,
          '(?:-)?(a|b-111|c-223)$'
          ) |
        stringr::str_detect(
          client_street_address,
          '(woodspring suites|relax in|super eight)'
        )
        ),
      client_street_address,
      client_msc
    ),
    # Remove address from un-resolvable entry
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'king dr and i'),
      NA_character_,
      client_street_address
    ),
    # Capture business names in entries
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
            client_street_address, 
            '(woodspring suites|relax in|super eight)'
          ),
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'woodspring suites') ~
          'woodspring suites',
        stringr::str_detect(client_street_address, 'relax in') ~ 'relax inn',
        stringr::str_detect(client_street_address, 'super eight') ~ 'super 8',
        TRUE ~ client_street_address_name
      ),
      client_street_address_name
    ),
    # Remove business names from entries
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
            client_street_address, 
            '(woodspring suites|relax in|super eight)'
          ),
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'woodspring suites') ~
          stringr::str_remove(client_street_address, ' woodspring suites'),
        stringr::str_detect(client_street_address, 'relax in') ~ 
          stringr::str_remove(client_street_address, ' at the relax in'),
        stringr::str_detect(client_street_address, 'super eight') ~ 
          stringr::str_remove(client_street_address, ' super eight'),
        TRUE ~ client_street_address
      ),
      client_street_address
    ),
    # Remove cross street from entry (invalid part of address)
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(& wald)(.+?)$'),
      stringr::str_remove(
        client_street_address, 
        stringr::str_match(client_street_address, '(& wald)(.+?)$')[,1]
        ),
      client_street_address
    ),
    # Remove secondary address from street address being duplicated
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'n. pan am expy'),
      stringr::str_remove(
        client_street_address, 
        'n. pan am expy '
        ),
      client_street_address
    ),
    # Capture Unit Types
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(apt| lot|#|room)(?: *)(.+)$'
          ),
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'room') ~ 'rm',
        stringr::str_detect(client_street_address, 'apt') ~ 'apt',
        stringr::str_detect(client_street_address, ' lot') ~ 'lot',
        TRUE ~ client_street_address_scnd1_type
      ),
      client_street_address_scnd1_type
    ),
    # Capture Unit Values (from those with a type)
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
        client_street_address, 
        '(apt| lot|#|room)(?: *)(.+)$'
        ),
        stringr::str_match(
          client_street_address, 
          '(apt| lot|#|room)(?: *)(.+)$'
          )[,3],
        client_street_address_scnd1_val
      ),
    # Remove unit type and value (from those with a type)
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(apt| lot|#|room)(?: *)(.+)$'
        ),
        stringr::str_remove(
          client_street_address,
          stringr::str_match(
            client_street_address, 
            '(?:--)?(apt| lot|#|room)(?: *)(.+)$'
            )[,1]
          ),
        client_street_address
    ),
    # Capture unit number (from those without a type)
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(?:-)?(a|b-111|c-223)$'),
      stringr::str_match(
        client_street_address, '(?:-)?(a|b-111|c-223)$')[,2],
      client_street_address_scnd1_val
    ),
    # Remove unit number from street address (from those without a type)
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(?:-)?(a|b-111|c-223)$'),
      stringr::str_remove(
        client_street_address,
        stringr::str_match(client_street_address, '(?:-)?(a|b-111|c-223)$')[,1]
        ),
      client_street_address
    ),
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))

aps <- dplyr::bind_rows(aps, modified_set)
```

We purged our checking subset and modified subset for memory management.

```{r}
rm(checking)
rm(modified_set)
```

##### Slashes

In prior cleaning and standardization, we found slashes in street address values. We isolated the 1,409 observations that contained a slash in the street address field for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([\\|/])')
  )

nrow(checking)
# [1] 1409
```

###### Anything other than a number on either side.

As the vast majority of entries appeared to have fractional numbers ("1/2") responsible for their inclusion in our checking subset, we could put these values aside for now to concentrate our cleaning efforts. We further refined our subset for concentrated cleaning by isolating entries that had something other than a number on either side of the slash. These 9 entries were isolated for further manual verification and cleaning.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([^0-9][\\|/])') |
      stringr::str_detect(client_street_address, '([\\|/][^0-9])') |
      stringr::str_detect(client_street_address,'^([\\|/])') |
      stringr::str_detect(client_street_address, '([\\|/])$')
    )

nrow(checking)
# [1] 9
```

Two of our values were not able to be resolved (highly invalid addressing, intersection with no other data). We shifted these values to the notes column, and otherwise eliminated them from the street address field.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Move to notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '([re][\\|/][hn])'),
      client_street_address,
      client_msc
    ),
    # Delete shifted value
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '([re][\\|/][hn])'),
      NA_character_,
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

Our remaining values were managed with point fixes: we eliminated a single instance of double slashes in a fractional address (and added a hyphen separator between the primary street number and the fractional component), we converted a slash to a hyphen for a hyphenated street name, and shifted a unit number suffix to our unit number value field.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Move to notes
    client_msc = ifelse(
      case_id %in% checking$case_id & (
        stringr::str_detect(client_street_address, '([0-9]+) (/ ([0-9]+))') |
        stringr::str_detect(client_street_address, '(e[\\|/]o)')|
        stringr::str_detect(client_street_address, '([0-9]+) (/ ([0-9]+))') |
        stringr::str_detect(client_street_address, 'us/ hwy') |
        stringr::str_detect(
          client_street_address, 
          '([0-9]+) ([0-9]+)//([0-9]+)'
          )
        ),
      client_street_address,
      client_msc
    ),
  ) |>
  dplyr::mutate(
    # Shift Unit Number to appropriate field
      client_street_address_scnd1_val = ifelse(
        case_id %in% checking$case_id &
          stringr::str_detect(client_street_address, '([0-9]+) (/ ([0-9]+))'),
        stringr::str_match(client_street_address, '([0-9]+) (/ ([0-9]+))')[,4],
        client_street_address_scnd1_val
      ),
      client_street_address = ifelse(
        case_id %in% checking$case_id,
        dplyr::case_when(
        # Convert slash to a hyphen for a hyphenated street name
          stringr::str_detect(client_street_address, '(e[\\|/]o)') ~ 
            stringr::str_replace(client_street_address, '([\\|/])', '-'),
        # Remove double-slash, add hyphenated separator
          stringr::str_detect(
            client_street_address, 
            '([0-9]+) ([0-9]+)//([0-9]+)'
            ) ~ 
            stringr::str_replace(
              client_street_address, 
              stringr::str_match(
                client_street_address, 
                '([0-9]+) ([0-9]+)//([0-9]+)'
                )[,1],
              paste0(
                  stringr::str_match(
                  client_street_address, 
                  '([0-9]+) ([0-9]+)//([0-9]+)'
                  )[,2],
                  '-',
                  stringr::str_match(
                  client_street_address, 
                  '([0-9]+) ([0-9]+)//([0-9]+)'
                  )[,3],
                  '/',
                  stringr::str_match(
                  client_street_address, 
                  '([0-9]+) ([0-9]+)//([0-9]+)'
                  )[,4]
                )
              ),
        # Remove slash and post-slash suffix that was a unit number
          stringr::str_detect(
            client_street_address, 
            '([0-9]+) (/ ([0-9]+))'
            ) ~ stringr::str_remove(
              client_street_address,
              stringr::str_match(
                client_street_address, 
                '([0-9]+) (/ ([0-9]+))')[,3]
              ),
        # Remove slash in highway address (likely typo)
          stringr::str_detect(client_street_address, 'us/ hwy') ~
            stringr::str_remove(client_street_address, '/'),
          TRUE ~ client_street_address
        ),
        client_street_address
      )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

###### Fraction as first portion of street address

We checked for any entries that started with a fractional number, as street numbers were not likely to be only a fraction. These 8 entries were isolated for further manual verification and cleaning.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '^([0-9]+[\\|/]+[0-9]+)')
    )

nrow(checking)
# [1] 8
```

One entry was gave "rural directions", though these were highly incomplete - as such, the value was shifted to the notes field. The remaining variations appeared to have a failed separator between the fractional "1/2" and the remaining numerical component of street address, which we corrected.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    ),
    # Remove street address from the unresolvable entry
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'e highway'),
      NA_character_,
      client_street_address
    ),
    # Fix the failed spaces between number and fraction
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address,'^(([0-9]+)(1/2))'),
      stringr::str_replace(
        client_street_address,
        stringr::str_match(client_street_address,'^(([0-9]+)(1/2))')[,2],
        paste0(
          stringr::str_match(client_street_address,'^(([0-9]+)(1/2))')[,3],
          '-1/2'
        )
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))

```


###### Fraction after first numerical values

We checked for any entries that had a fractional number immediately following the alphanumerical value at the start of the string. These 834 entries were isolated for further manual verification and cleaning.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(
      client_street_address, 
      '^(([0-9a-z]+)[^0-9a-z-]+)([0-9]+[\\|/][0-9]+)'
      )
    )

nrow(checking)
# [1] 834
```

While most of these values appeared to be valid and fixable by joining the fraction to the leading numbers with a hyphen rather than a white space, there were several rows which required further cleaning. Three were entirely un-resolvable, one had a unit number with a spacing failure, and three involved significant spacing failures. We addressed these observations.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Shift un-resolvable values to notes
    client_msc = ifelse(
      case_id %in% checking$case_id & (
        stringr::str_detect(client_street_address, '^(1/2 mile e)') |
        stringr::str_detect(client_street_address, '^(1 1/4 mile)') |
        stringr::str_detect(client_street_address, '^(8 1/2 miles)')
        ),
      client_street_address,
      client_msc
    ),
    # Spacing failures to notes
    client_msc = ifelse(
      case_id %in% checking$case_id & (
        stringr::str_detect(client_street_address, '^(1111/2)') |
        stringr::str_detect(client_street_address, '^(30081/2)') |
        stringr::str_detect(client_street_address, '^(91416)') |
        stringr::str_detect(client_street_address, '^(121237)') |
        stringr::str_detect(client_street_address, '^(1649 1/2 b)')
        ),
      client_street_address,
      client_msc
    ),
    # Catch unit number
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '^(1649 1/2 b)'),
      'b',
      client_street_address_scnd1_val
    )
  ) |>
  dplyr::mutate(
    # Shift unresolvable values to notes
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        # Remove unresolvable entries
        (
          stringr::str_detect(client_street_address, '^(1/2 mile e)') |
          stringr::str_detect(client_street_address, '^(1 1/4 mile)') |
          stringr::str_detect(client_street_address, '^(8 1/2 miles)')  
         ) ~ NA_character_,
        # Fix spacing failures in street number
        stringr::str_detect(
          client_street_address, '^(1111/2)'
          ) ~ stringr::str_replace(
            client_street_address, 
            '1111/2', 
            '111-1/2'
            ),
        stringr::str_detect(
          client_street_address, '^(30081/2)'
          ) ~ stringr::str_replace(
            client_street_address, 
            '30081/2', 
            '3008-1/2'
            ),   
        # Fix overall spacing failures and mutated numerical street names
        stringr::str_detect(
          client_street_address, '^(91416)'
        ) ~ '914-1/2 s 16th st',
        stringr::str_detect(
          client_street_address, '^(121237)'
        ) ~ '12123 7-1/2 st',
        stringr::str_detect(
          client_street_address, '^(1649 1/2 b)'
        ) ~ '1649-1/2 s 17th st ',
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We corrected the remaining values by collapsing the white space.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '^([0-9a-z]+) ([0-9]+/[0-9]+)'),
      stringr::str_replace(
        client_street_address,
        stringr::str_match(
            client_street_address,
            '^([0-9a-z]+) ([0-9]+/[0-9]+)'
          )[,1],
        paste0(stringr::str_match(
                  client_street_address,
                  '^([0-9a-z]+) ([0-9]+/[0-9]+)'
                )[,2],
              '-',
              stringr::str_match(
                  client_street_address,
                  '^([0-9a-z]+) ([0-9]+/[0-9]+)'
                )[,3]
              )
      ),
      client_street_address
    )
  )
```

###### Fraction at the End of the String

We checked for any entries that had a fractional number at the end of the string. These 242 entries were isolated for further manual verification and cleaning.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(
      client_street_address, 
      '([0-9]+[\\|/][0-9]+)$'
      )
    )

nrow(checking)
# [1] 242
```

There were 9 entries which appeared to consist of overlapping highways, which would have 3 potentially valid addresses (first highway, second highway, and both highways in street address). We isolated a copy of these values to create point-fixes, with the full address value in the notes field.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
  # Add 'triplicate' resolution entry values to notes field 
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '(highway|hwy) ([0-9]+/[0-9]+)$'
          ),
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))

# Isolate copies of values to create triplicates

modified_set <- aps |>
  dplyr::filter(
    case_id %in% checking$case_id & 
    stringr::str_detect(
          client_street_address, '(highway|hwy) ([0-9]+/[0-9]+)$'
          )
        )

modified_set2 <- modified_set
```

We modified the address values in our first modified set to use only the first highway name, and our second to use the second highway name only.

```{r}
modified_set <- modified_set |>
  dplyr::mutate(
    client_street_address = stringr::str_replace(
      client_street_address,
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9]+))$'
        )[,3],
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9]+))$'
        )[,4]
    )
  )

modified_set2 <- modified_set2 |>
  dplyr::mutate(
    client_street_address = stringr::str_replace(
      client_street_address,
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9]+))$'
        )[,3],
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9]+))$'
        )[,5]
    )
  )
```


All records found were in Texas. The majority (219) followed a "# avenue/ave [a-z] 1/2" formula, with entries in the cities of Galveston, Santa Fe, and Huntsville; these cities were confirmed to have matching 1/2 street values corresponding to these addresses, and were thus resolved by converting the white space between the street name and the 1/2 component into a hyphen.

The remaining 12 entries which required more detailed point-fixes. Two were not able to be fully resolved using the current data. Seven followed a similar formula, but had "County Road" values instead of avenues. Two appeared to omit the "Avenue" portion of the overall formula that dominated this subset. One appeared to be a phonetic typo ("Ave 2" instead of "Ave Q"). 


```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  # Shift un-resolvable entries to notes field
  dplyr::mutate(
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(e 1/2)$'),
    client_street_address,
    client_msc
    )
  ) |>
  dplyr::mutate(
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        # Remove street address from entirely unresolvable entry
        stringr::str_detect(
          client_street_address, 
          '(road e 1/2)$'
          ) ~ NA_character_,
        # Fix the entry that is slightly resolvable
        stringr::str_detect(
          client_street_address,
          '(gray e 1/2)$'
          ) ~ stringr::str_replace(
            client_street_address,
            stringr::str_match(
              client_street_address,
              '(gray e 1/2)$')[,2],
            'gray e-1/2'
            ),
        # Fix the streets which omit the "avenue" portion of the street name
        stringr::str_detect(
          client_street_address,
          '(?:[0-9]+)( n 1/2)$',
        ) ~ stringr::str_replace(
          client_street_address,
          '(n 1/2)$',
          'avenue n-1/2'
        ),
        # Fix the phonetic typo
        stringr::str_detect(
          client_street_address,
          '(ave 2 1/2)$',
        ) ~ stringr::str_replace(
          client_street_address,
          '(ave 2 1/2)$',
          'avenue 2-1/2'
        ),
        # Replace the white space between the 1/2 and other street name value
        # with a hyphen for other values
        stringr::str_detect(
          client_street_address,
          '(([0-9a-z]+) 1/2)$'
        ) ~ stringr::str_replace(
          client_street_address,
          stringr::str_match(
              client_street_address, 
              '(([0-9a-z]+) 1/2)$'
            )[,2],
            paste0(
              stringr::str_match(
              client_street_address, 
              '(([0-9a-z]+) 1/2)$'
            )[,3], '-1/2'
            )
          ),
        TRUE ~ client_street_address
        ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We then added our modified rows to our APS data set.

```{r}
aps <- dplyr::bind_rows(
  aps,
  dplyr::bind_rows(modified_set, modified_set2)
  )
```

We purged our modified subsets and checking subset for memory management.

```{r}
rm(modified_set)
rm(modified_set2)
rm(checking)
```


###### Remaining Slashes

We checked for any entries that had a fractional number that had not otherwise been resolved by utilizing a hyphen to join the fractional to the street number or street name. These 317 entries were isolated for further manual verification and cleaning.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([\\|/])')
    ) |>
  dplyr::filter(
    !stringr::str_detect(
      client_street_address, '([0-9a-z]+-[0-9a-z]+[\\|/][0-9a-z]+)'
      )
  )

nrow(checking)
# [1] 323
```

There were 9 entries which appeared to consist of overlapping highways, which would have 3 potentially valid addresses (first highway, second highway, and both highways in street address). We isolated a copy of these values to create point-fixes, with the full address value in the notes field.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
  # Add 'triplicate' resolution entry values to notes field 
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '(highway|hwy) ([0-9]+/[0-9]+ (e|s\\.))$'
          ),
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))

# Isolate copies of values to create triplicates

modified_set <- aps |>
  dplyr::filter(
    case_id %in% checking$case_id &
    stringr::str_detect(
          client_street_address, '(highway|hwy) ([0-9]+/[0-9]+ (e|s\\.))$'
          )
        )

modified_set2 <- modified_set
```

We modified the address values in our first modified set to use only the first highway name, and our second to use the second highway name only.

```{r}
modified_set <- modified_set |>
  dplyr::mutate(
    client_street_address = stringr::str_replace(
      client_street_address,
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9a-z ]+))$'
        )[,3],
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9a-z ]+))$'
        )[,4]
    )
  )

modified_set2 <- modified_set2 |>
  dplyr::mutate(
    client_street_address = stringr::str_replace(
      client_street_address,
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9a-z ]+))$'
        )[,3],
      stringr::str_match(
        client_street_address,
        '(highway|hwy) (([0-9]+)/([0-9a-z ]+))$'
        )[,5]
    )
  )

```

We had two observations which contained additional "rural direction" type values, but otherwise had a complete address. We shifted the original address values to the notes field, while eliminating the unnecessary components from our fields. We converted any space or " and " spacer to validate the remaining values.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Shift "fm 88" and "8 1/2 mile" full values to notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(fm 88|8 1/2 mile)$'),
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Convert ' and ' into a hyphen
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '( and )'),
      stringr::str_replace(
        client_street_address, '( and )', '-'
      ),
      client_street_address
    ),
    # Remove "FM 88" portion
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, "(fm 88)$"),
      stringr::str_remove(client_street_address, 'fm 88'),
      client_street_address
    ),
    # Remove "8 1/2 mile" portion
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, "(8 1/2 mile)$"),
      stringr::str_remove(client_street_address, '8 1/2 mile'),
      client_street_address
    ),
    # Remove space before fractional to resolve remaining values
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '( [0-9]{1}/)'),
      stringr::str_replace(
        client_street_address,
        stringr::str_match(client_street_address, '( ([0-9]{1})/)')[,2],
        paste0(
          "-", 
          stringr::str_match(client_street_address, '( ([0-9]{1})/)')[,3], 
          "/"
          )
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We added our modified rows back into our APS data set.

```{r}
aps <- dplyr::bind_rows(
  aps, 
  dplyr::bind_rows(modified_set, modified_set2
    )
  )
```

We purged our modified subsets and checking subset for memory management.

```{r}
rm(modified_set)
rm(modified_set2)
rm(checking)
```

We checked for any other remaining non-standard characters (anything other than a letter, number, white space, or hyphen. We found that there were 1,678 observations that continued to contain a non-standard character in the street address field.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([^a-z0-9 /-])')
  )

nrow(checking)
# [1] 1678
```

##### Periods (.)

There were 1,437 entries which contained a period (.) character.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(\\.)')
  )

nrow(checking)
# [1] 1437
```

Only one entry had data that required modification to ensure no meaningful data loss occurred in the bulk fix (replacing all periods with a single white space). We performed this point-fix and bulk fix.

```{r}
aps <- aps |>
  # Point-fix single entry that would lose valuable content if periods
  # converted to white space
  dplyr::mutate(
    client_street_address = ifelse(
      stringr::str_detect(client_street_address, 'mile 6.5 w'),
      stringr::str_replace(
        client_street_address, 
        'mile 6.5 w', 
        'mile 6-1/2 w'
        ),
      client_street_address
    )
  ) |>
  # Convert all periods to white space
  dplyr::mutate(
    client_street_address = stringr::str_replace_all(
      client_street_address, 
      '\\.', 
      ' ')
  )
```

##### Pound (#) Sign

There were 257 entries which contained a pound sign (#) character.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(#)')
  )

nrow(checking)
# [1] 257
```

The 7 entries that started with the symbol were isolated for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '^(#)')
  )

nrow(checking)
# [1] 7
```

These symbols could be omitted without any data loss, so we performed the omission.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_street_address = ifelse(
      stringr::str_detect(client_street_address, '^(#)'),
      stringr::str_remove(client_street_address, '^(#)'),
      client_street_address
    )
  )
```

There were no entries that ended with the symbol.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(#)$')
  )

nrow(checking)
# [1] 0
```

The 250 remaining entries that contained a pound (#) symbol were re-isolated for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(#)')
  )

nrow(checking)
# [1] 250
```

None of these were found to have significant data loss when the values after the pound (#) sign were shifted to the "unit value" field. This shift was performed for all entries that were not outside of the US, and the trimmed values removed from the street address field. 

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Shift all to notes
    client_msc = ifelse(
      case_id %in% checking$case_id & is.na(client_country) &
        stringr::str_detect(client_street_address, '(#)'),
      client_street_address,
      client_msc
    ),
    # Shift values to "unit value" field
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id & is.na(client_country) &
        stringr::str_detect(client_street_address, '(#)'),
      stringr::str_match(client_street_address, '([# ]+)([a-z0-9 ]+)$')[,3],
      client_street_address_scnd1_val
    ),
    # Remove from street address field
    client_street_address = ifelse(
      case_id %in% checking$case_id & is.na(client_country) &
        stringr::str_detect(client_street_address, '(#)'),
      stringr::str_remove(client_street_address,
                 stringr::str_match(
                   client_street_address, 
                   '([# ]+)([a-z0-9 ]+)$'
                   )[,1]
                 ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Ampersand (&) or word ( and )

In previous cleaning, we noted the use of the ampersand (&) character, along with use of "and" to add cross streets or other information.  We isolated the 126 observations that contained either an ampersand (&) or the word ( and ) in the street address field for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(&| and )')
  ) |>
  dplyr::filter(is.na(client_country))

nrow(checking)
# [1] 126
```

We copied any of our modified or un-resolvable street addresses to our notes field. As we had one entry with two street numbers, we isolated a copy of this value for point-modification, which would create one row for each of the street addresses present.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_msc = NA_character_
  ) |>
  dplyr::mutate(
    # Add to notes
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        !stringr::str_detect(
        client_street_address,
        paste0(
          '(est ri|gate|[0-9] 5th|w ave l|[^a-z]l and m|[^a-z]t and p|',
          'sand and gra|[^a-z]h and r|s and w|f and b|tt and wh|',
          'ann and dos|ots and sa|wn and co|r and r|a and m|',
          'reel and ri|a and a|ks and ho|ob and be|ill and da|',
          'a&m| and one half)'
          )),
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
   ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))

modified_set <- aps |>
  dplyr::filter(stringr::str_detect(client_street_address, '^([0-9]+&[0-9]+)'))
```

We then performed our point modifications. We took the second value of the street address (for the entry we duplicated) in our separated row, and the first in our combined data. We also isolated two business names, fixed an address which was primarily a business name, added an address from a business name, updated a city and zip from an intersection, removed cross streets, and removed un-resolvable values. We then re-added our modified data into our combined data set.

```{r}
modified_set <- modified_set |>
  dplyr::mutate(
    client_street_address = stringr::str_remove(
      client_street_address, '^([0-9]+&)'
      )
  )

aps <- aps |>
  dplyr::mutate(
  # Capture business names
  client_street_address_name = ifelse(
    case_id %in% checking$case_id &
      stringr::str_detect(
        client_street_address,
        '(wellness and rehab|t h and f)'),
    dplyr::case_when(
      stringr::str_detect(
        client_street_address,
        'wellness and rehab') ~ client_street_address,
      stringr::str_detect(
        client_street_address,
        't h and f') ~ 'thf: teague hunting and fishing club',
      TRUE ~ client_street_address_name
      ),
    client_street_address_name
    ),
  # Capture city and zip code from an intersection
  client_city = ifelse(
    case_id %in% checking$case_id &
      stringr::str_detect(
        client_street_address,
        '(university and)'),
    'fort worth',
    client_city
  ),
  client_zip_code = ifelse(
    case_id %in% checking$case_id &
      stringr::str_detect(
        client_street_address,
        '(university and)'),
    '76107',
    client_zip_code
  ),
  # Add street address
  client_street_address = ifelse(
    case_id %in% checking$case_id &
      stringr::str_detect(
        client_street_address,
        '(wellness and rehab)'),
    '2001 forest ridge dr',
    client_street_address
  ),
  # Street name point modifications
  client_street_address = ifelse(
    case_id %in% checking$case_id,
    dplyr::case_when(
      # Completely add an address to a business
      stringr::str_detect(client_street_address, '(wellness and rehab)') ~
        '2001 forest ridge dr',
      # Change street name entirely
      stringr::str_detect(client_street_address, 't h and f') ~
        stringr::str_replace(
          client_street_address, 't h and f club rd', 'gate 6'
          ),
      # Take first version of street address for the duplicated entry
      stringr::str_detect(client_street_address, 'westcreek') ~
        stringr::str_remove(client_street_address, '(&[0-9]+)'),
      # Fix typo of "alley"
      stringr::str_detect(client_street_address, '(aly)$') ~
        stringr::str_replace(client_street_address, '(aly)$', 'alley'),
      # fix "and one half" to properly be a #-1/2 street number
      # Remove cross street, fix typo in street name
      stringr::str_detect(client_street_address, '(bryant blvd)$') ~
        stringr::str_replace(
          client_street_address,
          stringr::str_match(
            client_street_address, 
            '^([0-9]+) ((.+?) & south (?:.+?))$'
            )[,3],
          'w ave l'),
      # Fix "and one half" to appropriately "-1/2" in number
      stringr::str_detect(client_street_address, '( and one half)') ~
        stringr::str_replace(
          client_street_address, '( and one half)', '-1/2'
          ),
      # Remove a cross street
      stringr::str_detect(client_street_address, '(& doak)$') ~
        stringr::str_remove(client_street_address, '(& doak)$'),
      # Standardize a street name
      stringr::str_detect(client_street_address, 'a&m') ~
        stringr::str_replace(client_street_address, 'a&m', 'a and m'),
      # Remove street address for any un-resolvable entries
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(est ri|gate|[0-9] 5th|w ave l|[^a-z]l and m|[^a-z]t and p|',
          'sand and gra|[^a-z]h and r|s and w|f and b|tt and wh|',
          'ann and dos|ots and sa|wn and co|r and r|a and m|',
          'reel and ri|a and a|ks and ho|ob and be|ill and da|',
          'a&m| and one half)'
          )) ~ NA_character_,
      TRUE ~ client_street_address
    ),
    client_street_address
  ),
  )

aps <- dplyr::bind_rows(aps, modified_set)
```

We purged our checking subset and modified set for memory management

```{r}
rm(checking)
rm(modified_set)
```

##### Any remaining special characters

We checked for any other remaining non-standard characters (anything other than a letter, number, white space, or hyphen. We isolated the remaining 34 observations that continued to contain a non-standard character in the street address field for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '([^a-z0-9 /-])')
  ) |>
  dplyr::filter(is.na(client_country))

nrow(checking)
# [1] 34
```

We isolated the few remaining business names and unit numbers. Those entries with single quotes appeared to be valid. We removed any other invalid characters and standardized our white spaces.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Add Addresses that are being modified to notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        (stringr::str_detect(client_street_address,'([\t|@|:])') |
        !stringr::str_detect(client_street_address, '([0-9]+)')) |
        stringr::str_detect(client_street_address, '(apt)$'),
      client_street_address,
      client_msc
      ),
    # Capture unit type
    client_street_address_scnd1_type = ifelse(
      stringr::str_detect(client_street_address, '(apt)$'),
      'apt',
      client_street_address_scnd1_type
    ),
    # Capture most business names
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, '([0-9]+)'),
      client_street_address,
      client_street_address_name
    ),
    # Capture other business name
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '^(tccc:)'),
      'tccc: texoma christian care center',
      client_street_address_name
    ),  
    # Update city from business
    client_city = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'evergreen'),
      "farmer's branch",
      client_city
    ),
    # Modify street addresses
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        # Remove formatting string
        stringr::str_detect(client_street_address, '(\t)') ~ 
          stringr::str_remove_all(client_street_address, '(\t)'),
        # Remove the 'apt' suffix
        stringr::str_detect(client_street_address, '(apt)$') ~
          stringr::str_remove(client_street_address, '(; apt)$'),
        # Remove cross street
        stringr::str_detect(client_street_address, '@') ~
          stringr::str_remove(client_street_address, '( @.+?)$'),
        # Add address from business name
        stringr::str_detect(client_street_address, 'evergreen') ~
          '11701 mira lago blvd',
        # Remove business names
        !stringr::str_detect(client_street_address, '([0-9]+)') ~ 
          NA_character_,
        stringr::str_detect(client_street_address, '^(tccc: )') ~
          stringr::str_remove(client_street_address, 'tccc: '),
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
    # Replace any remaining special characters with a white space
    # except hyphen, forward slash, white space, or single quote
    client_street_address = stringr::str_replace_all(
      client_street_address, "([^a-z0-9 '/-])", " "
    ),
    # Standardize white spaces so there are no duplicate white spaces
    client_street_address = stringr::str_replace_all(
      client_street_address, "( ){2,}", " "
      ),
    # Trim leading and trailing white space
    client_street_address = stringr::str_trim(client_street_address)
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We purged our checking subset for memory management.

```{r}
rm(checking)
```

#### Separation of Secondary Street Address Values

We then turned towards separating secondary address values, such as building, apartment, room, and other values.

##### Apartment

Apartment was found to most commonly have 'apartment', 'apt', or 'appt' as the prefix. We also recognized several street names with 'baptist', 'zapta', and variations of 'captain' which were 'false matches'. We isolated the 271 observations with one of our possible suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(apartment|apt|appt)') &
      !stringr::str_detect(
      client_street_address, 
      '(captain|capt|baptist enc|zapta rd)')
  )

nrow(checking)
# [1] 271
```

Apartment appeared to (with very few exceptions) appear at the end of the string. We also caught several entries which included apartment complex names but no actual address. 

We performed our point fixes. Luckily, apartment numbers (outside of our point fixes) appeared at the end of strings, the only pre-existing value for 'unit type' was apartment numbers, and any unit with a value for apartment number still within the street address had a missing (`NA`) value for 'unit value'.


```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Add all original addresses to notes, unless there is both an 
    # apartment as "unit type" and a number in "unit number"
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        (is.na(client_street_address_scnd1_type)|
        is.na(client_street_address_scnd1_val)),
      client_street_address,
      client_msc
    ),
    # Isolate apartment from a switched-order entry
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'rear apt'),
      'rear',
      client_street_address_scnd1_val
    ),
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'rear apt'),
      'apt',
      client_street_address_scnd1_type
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'rear apt'),
      stringr::str_remove(client_street_address, ' rear apt'),
      client_street_address
    ),
    # Isolate apartment from a scrambled entry
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'tigoni'),
      stringr::str_match(client_street_address, '^([a-z ]+?) apt ([0-9]+)')[,2],
      client_street_address_name
    ),
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'tigoni'),
      stringr::str_match(client_street_address, '^([a-z ]+?) apt ([0-9]+)')[,3],
      client_street_address_scnd1_val
    ),
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'tigoni'),
      'apt',
      client_street_address_scnd1_type
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'tigoni'),
      '1527 w sunshine dr',
      client_street_address
    ),
    # Shift complex names to names field
    client_street_address_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'ranch ap') ~ 
          paste('mariposa at', client_city),
        stringr::str_detect(client_street_address, 'camalot') ~ 
          client_street_address,
        stringr::str_detect(client_street_address, 'sedona') ~ 
          client_street_address,
        stringr::str_detect(client_street_address, 'costal') ~ 
          'coastal haven senior apartments',
        stringr::str_detect(client_street_address, 'peach') ~ 
          client_street_address,
        stringr::str_detect(client_street_address, 'posada') ~ 
          client_street_address,
        stringr::str_detect(client_street_address, 'breezey') ~ 
          'lake breeze apartments',
        stringr::str_detect(client_street_address, 'studio 6') ~ 
          paste0(client_street_address, ', medical center'),
        TRUE ~ client_street_address_name
      ),
      client_street_address_name
    ),
    # Replace complex names with street addresses
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'ranch ap') ~ 
          '1301 w whitestone blvd',
        stringr::str_detect(client_street_address, 'camalot') ~ 
          '5241 alamo dr',
        stringr::str_detect(client_street_address, 'sedona') ~ 
          '2601 nonesuch rd',
        stringr::str_detect(client_street_address, 'costal') ~ 
          '4710 middlecoff cir',
        stringr::str_detect(client_street_address, 'peach') ~ 
          '3150 peachetree st',
        stringr::str_detect(client_street_address, 'posada') ~ 
          '901 lamar st',
        stringr::str_detect(client_street_address, 'breezey') ~ 
          '6011 i-30 frontage rd',
        stringr::str_detect(client_street_address, 'studio 6') ~ 
          '7719 pasteur ct',
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
    # Add 'apt' as the unit type for any row we are extracting from
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(apartments|apartment|apt|appt)( )?([ 0-9a-z]+)$'),
      'apt',
      client_street_address_scnd1_type
    ),
    # Extract Apartment Numbers
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(apartments|apartment|apt|appt)( )?([ 0-9a-z]+)$') &
        is.na(client_street_address_scnd1_val),
      stringr::str_match(
        client_street_address, 
        '(apartments|apartment|apt|appt)( )?([ 0-9a-z]+)$'
        )[,4],
      client_street_address_scnd1_val
    ),
    # Remove apartment from street address field
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(apartments|apartment|apt|appt)( )*?([ 0-9a-z]*)$'),
      stringr::str_remove(
        client_street_address,
        stringr::str_match(
          client_street_address, 
          '(apartments|apartment|apt|appt)( )*?([ 0-9a-z]*)$'
          )[,1]
        ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Building

Building was found to most commonly have 'bldg' or 'bd' as the prefix.  We isolated the 14 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(building|bldg|bd)')
  )

nrow(checking)
# [1] 14
```

Nearly all of the observations were caught because of street name values, and required no further modification. We had two entries which required shifting of secondary address values (one which also had an apartment number, so use of the second secondary set was required) and one which only contained a subdivision name. We performed our modifications.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Add entry that does not have address in notes and subdivision only
    # entry to notes field
    client_msc = ifelse(
      case_id %in% checking$case_id &
        (stringr::str_detect(client_street_address, 'bldg 11') |
           !stringr::str_detect(client_street_address, '([0-9])')),
      client_street_address,
      client_msc
    ),
    # Add subdivision to address name field
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, '([0-9])'),
      client_street_address,
      client_street_address_name
    ),
    # Point-fixes, 'bldg 11'
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'bldg 11'),
      'bldg',
      client_street_address_scnd1_type
    ), 
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'bldg 11'),
      '11',
      client_street_address_scnd1_val
    ), 
    # Point-fixes, 'bd 6' 
    client_street_address_scnd2_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'bd 6'),
      'bldg',
      client_street_address_scnd2_type
    ), 
    client_street_address_scnd2_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'bd 6'),
      '6',
      client_street_address_scnd2_val
    ), 
    # Street Address fixes
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'bldg 11') ~
          stringr::str_remove(client_street_address, ' bldg 11'),
        stringr::str_detect(client_street_address, 'bd 6') ~
          stringr::str_remove(client_street_address, ' bd 6'),
        !stringr::str_detect(client_street_address, '([0-9])') ~ 
          NA_character_,
      TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Room

Room was found to most commonly have 'room' or 'rm' as the prefix. This required significant manual trimming due to the prevalence of 'rm' as a combination in text (such as in the common abbreviation of "strm" for "stream" in street names), without being able to rely upon spacing or room numbers only containing numbers (as "room a" or "room b12" are both technically valid and possible).  We isolated the 21 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(room|rm)') &
      !stringr::str_detect(
        client_street_address, 
        paste0(
          '(croom|groom|broom|man|arm|ermud|hermi|rmont|orm|strm|urmu|irmo|',
          'hermo|derm|mark|everm|rmillion|term|rmil|birm|rmou|verm|',
          'therm|irma|perm|bermac|lermo|erma|fermin|hrmu|turme|urmi|',
          'irme|erme|urma|ermo|ermi|ermo|ermo|urmo|ermi|erms|urmei|herm|nairm)'
          )
      )
  )

nrow(checking)
# [1] 21
```

There were two addresses which required point fixes. Otherwise, our addresses had room number at the end of the street address field. We performed our modifications.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Add to notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_val),
      client_street_address,
      client_msc
    ),
    # Shift business name
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'lions den'),
      "lion's den extended stay",
      client_street_address_name
    ),
    # Point-fix addresses
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '^([0-9]+) rm ([0-9]+)$'
          ),
      stringr::str_replace(client_street_address, 'rm', 'ranch rd'),
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'lions den'),
      stringr::str_replace(
        client_street_address,
        stringr::str_match(
            client_street_address, 
            '^([0-9]+ lions den )(.+?)$')[,2],
        '3000 tx hwy 50 ' 
        ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
    # Extract room numbers
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_val) &
        stringr::str_detect(
          client_street_address, 
          '(room|rm)(?: )?([ 0-9a-z]+)$'),
      stringr::str_match(
        client_street_address, 
        '(room|rm)(?: )?([ 0-9a-z]+)$'
        )[,2],
      client_street_address_scnd1_val
    ),
    # Add room number to unit type
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_type) &
        stringr::str_detect(
          client_street_address, 
          '(room|rm)(?: )?([ 0-9a-z]*)$'
          ),
      'rm',
      client_street_address_scnd1_type
    ),
    # Remove room number from address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(room|rm)(?: )?([ 0-9a-z]*)$'
          ),
      stringr::str_remove(
        client_street_address,
        stringr::str_match(
          client_street_address, 
          '(room|rm)(?: )?([ 0-9a-z]*)$'
          )[,1]
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))  
```

##### Suite

Suite was found to most commonly have 'suite' as the prefix. We isolated the 5 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(suite)') &
      !stringr::str_detect(
        client_street_address, 
        paste0(
          '(suiter)'
          )
        )
  )

nrow(checking)
# [1] 5
```

Only one of these entries had a suite number. The remainder were business names. We performed our modifications.

```{r}
aps <- aps |>
# Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Capture names as notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    ),
    # Move business names to the name field
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, 'lane'),
      client_street_address,
      client_street_address_name
    ),
    # Extract suite number
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'lane'),
      stringr::str_match(client_street_address, '^(.+?) suite ([0-9]+)$')[,3],
      client_street_address_scnd1_val
    ),
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'lane'),
      'suite',
      client_street_address_scnd1_type
    ),
    # Fix Addresses
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'lane') ~
          stringr::str_match(client_street_address, '^(.+?) suite ([0-9]+)$')[,2],
        stringr::str_detect(client_street_address, 'woodspring') ~ 
          '255 i-45 n',
        stringr::str_detect(client_street_address, 'express inn') ~ 
          '1100 e palestine ave',
        stringr::str_detect(client_street_address, 'candlewood') ~ 
          '2401 e tx hwy 190',
        stringr::str_detect(client_street_address, 'wood spring') ~ 
          '3210 s sw loop 323',
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc)) 
```

##### Lot

Lot was found to most commonly have 'lot' as the prefix. This required significant filtering due to the prevalence of 'lot' within names in both English and Spanish that may be used in street names, and its inclusion within other words as a short combination. We isolated the 48 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(lot)')     &
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(camelot|lotus|lott ave|oodlot|illot|palote|lotta|rlota|',
          'olota|lotz|lotte|celot|pilot|helotes|sloth|lotts|loth|',
          'lottie|lott rd|ollote|merlot|alote|clot|lotto|jimlot|lott st|',
          'thelot|lotan)'
          )
        )
  )

nrow(checking)
# [1] 48
```

There were three addresses that could not be fully resolved: one was incomplete (entirely lacked a street number), the second appeared to follow a mineral rights format (parcel lots), and another was a highly rural address that could not be verified to exist using online mapping tools. We also had several entries which had already had unit numbers separated in pound (#) sign cleaning, and some with "lot" preceding values which appeared to actually indicate street numbers. We also had a business due to the value of "parking lot". 

We performed our point fixes.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes, if not already in notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_val),
      client_street_address,
      client_msc
    ),
    # Shift business name, update address
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'parking lot'),
      client_street_address,
      client_street_address_name
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'parking lot'),
      '752 wynnewood dr',
      client_street_address
    ),
    # Remove leading "lots" from target entries
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_starts(client_street_address, 'lot') &
        !stringr::str_detect(client_street_address, 'lomi'),
     stringr::str_remove(client_street_address, 'lot '),
     client_street_address
    ),
    # Update ZIP Code, remove city, state, zip from street address
    client_zip_code = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'lott tx'),
      stringr::str_match(
        client_street_address, 
        '^(.+?)( lott tx ([0-9]+))$'
        )[,4],
      client_zip_code
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'lott tx'),
      stringr::str_match(
        client_street_address, 
        '^(.+?)( lott tx ([0-9]+))$'
        )[,2],
      client_street_address
    ),
    # Point fix of an address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, ' 89 '),
      stringr::str_replace(client_street_address, ' 89 ', ' 59 '),
      client_street_address
    ),
  ) |>
  dplyr::mutate(
    # Add "lot" as secondary unit type
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(lot[ 0-9a-z]*)$') &
        !stringr::str_starts(client_street_address, '221 l') &
        !stringr::str_detect(client_street_address, 'lomi'), 
      'lot',
      client_street_address_scnd1_type
    ),
    # Remove trailing "lot"
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_ends(client_street_address, 'lot'), 
      stringr::str_remove(client_street_address, ' lot'),
      client_street_address
    ),
    # Extract lot numbers at the end of fields
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'lot ([0-9a-z]+)$') &
        !stringr::str_starts(client_street_address, '221 l') &
        !stringr::str_detect(client_street_address, 'lomi'),
      stringr::str_match(client_street_address, 'lot ([0-9a-z]+)$')[,2],
      client_street_address_scnd1_val
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, '(lot ([0-9a-z]+))$') &
        !stringr::str_starts(client_street_address, '221 l') &
        !stringr::str_detect(client_street_address, 'lomi'),
      stringr::str_remove(
        client_street_address,
        stringr::str_match(client_street_address, 'lot ([0-9a-z]+)$')[,1]
        ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Space

Space was found to most commonly have 'space', 'spc' or 'spce' as the prefix. This required filtering to eliminate valid values with 'space' or its variants. We isolated the 23 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(space|spce|spc)')     &
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(space center blvd|space blvd|space cir|space danzi|spc johnny|',
          'spaceway dr|space ln|space shuttle ln)'
          )
        )
  )

nrow(checking)
# [1] 23
```

We had a single entry which had previously had the unit number value shifted in the pound (#) cleaning. Other units required little modification, with the sole exception of two misspelled streets. We performed our modifications.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes, if not already in notes
    client_msc = ifelse(
      case_id %in% checking$case_id &
        is.na(client_street_address_scnd1_val),
      client_street_address,
      client_msc
    ),
    # Add "Space" as unit type"
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id,
      'spc',
      client_street_address_scnd1_type
    ),
    # Split unit number
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id & 
        is.na(client_street_address_scnd1_val),
      stringr::str_match(
        client_street_address, 
        '((space|spce|spc)(?: )?([0-9a-z]+))$'
        )[,4],
      client_street_address_scnd1_val
    ),
    # Modify Address to remove the Space Values
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      stringr::str_remove(
        client_street_address,
        stringr::str_match(
          client_street_address, 
          '((space|spce|spc)(.*?))$'
          )[,1]
        ),
      client_street_address
      ),
    # Two point-fixes to address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'westpark act'),
      stringr::str_replace(
        client_street_address,
        'westpark act',
        'w park ave'),
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'ncrd'),
      stringr::str_replace(
        client_street_address,
        'ncrd',
        'n cr'),
      client_street_address
    ),
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Trailer

Trailer was found to most commonly have 'trailer', or 'trlr' as the prefix. Any 'trl' values were found to be irrelevant in exploration, thus the value was omitted from our regular expression. This required filtering to eliminate valid values with 'trailer' or its variants. We isolated the 11 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(trailer|trlr)')  &
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(trailerdell st|trailertopia cir)'
          )
        )
  )

nrow(checking)
# [1] 11
```

Two rural addresses required no change, as they were found to be valid full street addresses. Four required some modification to the street name. The remainder were simply split based on protocol. We performed our modifications.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes, if changes to be made
    client_msc = ifelse(
      case_id %in% checking$case_id &
        (stringr::str_detect(
          client_street_address, 
          '(north trai|groves|6 n trai|gloria)'
          )|
           stringr::str_detect(
          client_street_address, 
          '(trailer|trlr) ([0-9]+)$'
          )
         ),
      client_street_address,
      client_msc
    ),
    # Update street addresses
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_street_address, 'north trailer') ~
            stringr::str_c(
              stringr::str_match(
                client_street_address, 
                '^([0-9a-z]+)(.*?)$'
              )[,2], 
            ' trailor'
            ),
        stringr::str_detect(client_street_address, 'groves') ~
          stringr::str_c(
              stringr::str_match(
                client_street_address, 
                '^([0-9a-z]+)(.*?)$'
              )[,2], 
            ' sheppard rd'
            ),   
        stringr::str_detect(client_street_address, '6 n trai') ~ 
          stringr::str_c(
              stringr::str_match(
                client_street_address, 
                '^([0-9]+) (.+?)$'
                )[,2],
              ' fm ',
              stringr::str_match(client_street_address, '^([0-9]+) (.+?)$')[,3]
            ),
        stringr::str_detect(client_street_address, 'gloria') ~ 
            stringr::str_c(
                stringr::str_match(
                  client_street_address, 
                  '^([0-9]+ gloria) (.+?)$'
                  )[,2],
                ' ranch ',
                stringr::str_match(
                  client_street_address, 
                  '^([0-9]+ gloria) (.+?)$'
                  )[,3]
            ),
        TRUE ~ client_street_address
      ),
      client_street_address
    ),
    # Extract Trailer Numbers
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(trailer number|trailer|trlr)(?: )?([0-9a-z]+)$'
          ) &
        !stringr::str_detect(client_street_address, '(park)$'),
      stringr::str_match(
        client_street_address, 
        '(trailer number|trailer|trlr)(?: )?([0-9a-z]+)$'
        )[,3],
      client_street_address_scnd1_val
    ),
    # Add 'trlr' unit type
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id &
        !is.na(client_street_address_scnd1_val),
      'trlr',
      client_street_address_scnd1_type
    ),
    # Remove trailer number from street address field
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, 
          '(trailer number|trailer|trlr)(?: )?([0-9a-z]+)$'
          ) &
        !stringr::str_detect(client_street_address, '(park)$'),
      stringr::str_match(
        client_street_address, 
        '^(.+?)(?: )?(trailer number|trailer|trlr)(?: )?([0-9a-z]+)$'
        )[,2],
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Rear

Rear was a potential unit designation that was most likely to be a suffix. Any 'back' values were found to be irrelevant in exploration, thus the value was omitted from our regular expression. We isolated the 18 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(rear)')  &
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(reary|reardo|rearde)'
          )
      )
  )

nrow(checking)
# [1] 18
```

We had one heavily garbled street address which was human-understandable but would have significant avoidable string-distancing inflation without correction. We had a single variant that had "rear b" instead of just "rear" or "b". Other values were confirmed as likely to be valid, and split by protocol. We performed our modifications.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes
    client_msc = ifelse(
      case_id %in% checking$case_id ,
      client_street_address,
      client_msc
    ),
    # Heavily misspelled but human-understood street name
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'vusr'),
      stringr::str_replace(
        client_street_address,
        stringr::str_match(client_street_address, '(?:[0-9]+ )(.*?)$')[,2],
        'us 83 bus rear'
      ),
      client_street_address
    ),
    # Extract values
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_street_address, '(rear b)$') ~ 'rear b',
        stringr::str_detect(client_street_address, 'rear') ~ 'rear',
        TRUE ~ client_street_address_scnd1_val
      ),
      client_street_address_scnd1_val
    ),
    # Remove from street address field
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_street_address, '(rear b)$') ~ 
          stringr::str_remove(client_street_address, 'rear b'),
        stringr::str_detect(client_street_address, 'rear') ~ 
          stringr::str_remove(client_street_address, 'rear'),
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Stop

Stop was a potential unit designation that was most likely to be a suffix. We isolated the 5 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(stop)')  &
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(topher|whistle stop)'
          )
      )
  )

nrow(checking)
# [1] 5
```

We had one un-resolvable address, and another which was found to simply be a valid street address that included the word "stop". No changes made.

##### Unit

Unit was a potential unit designation that was most likely to be a suffix. We isolated the 12 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(unit)')  &
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(community|united|opportunity|unity)'
          )
      )
  )

nrow(checking)
# [1] 12
```

There was one address which was predominantly a business name. We corrected this entry and separated our unit values and types.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes
    client_msc = ifelse(
      case_id %in% checking$case_id ,
      client_street_address,
      client_msc
    ),
    # Capture unit value
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id,
      stringr::str_match(client_street_address, '(?:unit )([0-9a-z]+)')[,2],
      client_street_address_scnd1_val
    ),
    # Capture unit type
    client_street_address_scnd1_type = ifelse(
      case_id %in% checking$case_id,
      'unit',
      client_street_address_scnd1_type
    ),
    # Remove unit and value from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      stringr::str_remove(
        client_street_address,
        stringr::str_match(client_street_address, '(unit [0-9a-z]+)')[,2]
        ),
      client_street_address
    ),
    # Extract business name
    client_street_address_name = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, '([0-9])'),
      client_street_address,
      client_street_address_name
    ),
    # Change business address to actual street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, '([0-9])'),
      '23 mcclernad rd',
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Box

Box was a potential unit designation that was most likely to be a suffix. We isolated the 85 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(box)')   &
      !stringr::str_detect(
        client_street_address,
        paste0(
          '(boxer|boxwood|woodbox|box elder|box canyon|ten box rd|boxhill|',
          'box factory|tee box ct|boxcar|boxelder|box ranch)'
          )
      )
  )

nrow(checking)
# [1] 85
```

The vast majority of caught entries followed a "(hr|hcr|rr|rt|fm) ([0-9a-z]+) box ([0-9a-z]+)" or similar formula. We had one un-resolvable entry, one jumbled/disorganized entry, one that had a (likely unintentionally) omitted 'rr' prefix, one that had a secondary address unit value for the 'box', and several 'box' streets which were found to be valid. We processed our rural formula by shifting the 'box' values to street numbers (first part of street address) unless otherwise specified. We performed our modifications.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes, if modifying
    client_msc = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(
          client_street_address, 
          '(strong box|box rd|box s dr|box t dr|box k ln)'
          ),
      client_street_address,
      client_msc
    ),
    # Shift single value to secondary value
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'county road'),
      stringr::str_match(client_street_address, 'box ([0-9]+)$')[,2],
      client_street_address_scnd1_val
    ),
    # Point-modification of addresses
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        # Remove box that was a secondary unit
        stringr::str_detect(client_street_address, 'county road') ~
          stringr::str_remove(
            client_street_address,
            stringr::str_match(client_street_address, '(box [0-9]+)$')[,2]
          ),
        # Un-resolvable entry with attempted modification
        stringr::str_detect(client_street_address, '(i)$') ~ paste0(
          stringr::str_match(
            client_street_address, 
            '^(?:rr) ([0-9]+) box ([0-9]+) (?:i)$'
            )[,3], 
          ' i-', 
          stringr::str_match(
            client_street_address, 
            '^(?:rr) ([0-9]+) box ([0-9]+) (?:i)$'
            )[,2],
          ' s'
          ),
        # Add 'rr' prefix
        stringr::str_detect(client_street_address, '^([0-9] box [0-9]+)') ~
          paste0('rr ', client_street_address),
        # Fix order of jumbled entry
        stringr::str_detect(
          client_street_address, 
          '(box ([0-9]+) ([a-z]) highway)'
          ) ~ paste0(
            stringr::str_match(
              client_street_address, 
              '^(.+?) (box ([0-9]+) ([a-z]) highway)'
              )[,2], 
            ' box ', 
            stringr::str_match(
              client_street_address, 
              '^(.+?) (box ([0-9]+) ([a-z]) highway)'
              )[,4], 
            stringr::str_match(
              client_street_address, 
              '^(.+?) (box ([0-9]+) ([a-z]) highway)'
              )[,5]
            ),
        TRUE ~ client_street_address
      ),
      client_street_address
    ),
    # Reorder entries so "box" value is the street number
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '^(.+?) box ([0-9a-z]+)$') &
        !stringr::str_detect(
          client_street_address, 
          '(strong box|box rd|box s dr|box t dr|box k ln)'
          ),
      paste0(
        stringr::str_match(
          client_street_address, 
          '^(.+?) box(?: )?([0-9a-z]+)$'
          )[,3], 
        ' ', 
        stringr::str_match(
          client_street_address, 
          '^(.+?) box(?: )?([0-9a-z]+)$'
          )[,2]
        ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### House

House was a noted suffix, which likely indicated the house number (typically at the start of the street address field) but also found at the end in some systems. We isolated the 5 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(house)') &
      !stringr::str_detect(
        client_street_address,
        paste0('(house st|house ln|house ave|house rd|house way|house blvd|',
               'house dr|house cir|house ct|house pl|houser)'
               )
        ) &
      !stringr::str_detect(
        client_street_address,
        paste0('(ranch house|monk house|lighthouse|stillhouse|greenhouse|',
               'hillhouse|school house|house hahl|whitehouse|house ander|',
               'housefin|tenhouse|house wren|smokehouse)'
               )
      )
  )

nrow(checking)
# [1] 5
```

The caught entries appeared to be jumbled or disorganized, and were fixed with point-mutations.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    ),
    # Add secondary value
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'half'),
      stringr::str_match(client_street_address, '([0-9]+)$')[,2],
      client_street_address_scnd1_val
    ),
    # Modify street address
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        # Disorganized entry
        stringr::str_detect(client_street_address, 'cr') ~ paste0(
          stringr::str_match(
            client_street_address, 
            '^([0-9]+) cr house ([0-9]+)$'
            )[,3], 
          ' cr ', 
          stringr::str_match(
            client_street_address, 
            '^([0-9]+) cr house ([0-9]+)$'
            )[,2]
          ),
        # 'half' entry
        stringr::str_detect(client_street_address, 'half') ~ paste0(
            stringr::str_match(
              client_street_address, 
              '^(.+?) half (.+?) house'
              )[,2], 
            '-1/2 ', 
            stringr::str_match(
              client_street_address, 
              '^(.+?) half (.+?) house'
              )[,3]
            ),
        # Remove 'house no' prefix
        stringr::str_detect(client_street_address, '^(house no)') ~ 
          stringr::str_remove(client_street_address, 'house no '),
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Number

Number was a potential unit designation that was most likely to be a suffix. We isolated the 16 observations that matched our potential suffixes for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    is.na(client_country) &
    (stringr::str_detect(client_street_address, '( no |number| no[0-9])') |
      stringr::str_detect(client_street_address, '( no)$'))
  )

nrow(checking)
# [1] 16
```

We had three street addresses that contained the word "no" but were found to otherwise be valid. We shifted the remaining fields per protocol after verification in manual review. We performed our modifications.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy into notes, if changes to be made
    client_msc = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, '(no bog|no mor|old no)'),
      client_street_address,
      client_msc
    ),
    # Extract Values
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, '(no bog|no mor|old no)'),
      dplyr::case_when(
        # Single value without the proper prefix
        stringr::str_detect(client_street_address, '^(.+? [0-9]+) ([0-9]+)$') ~
          stringr::str_match(
            client_street_address, 
            '^(.+? [0-9]+) ([0-9]+)$'
            )[,3],
        # Most values
        stringr::str_detect(
          client_street_address, 
          '^(.+?) ((?:no|number) ([0-9a-z]+))'
          ) ~ stringr::str_match(
            client_street_address, 
            '^(.+?) ((?:no|number) ([0-9a-z]+))'
            )[,4], 
        TRUE ~ client_street_address_scnd1_val
      ),
      client_street_address_scnd1_val
    ),
    # Remove unit/number values from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        !stringr::str_detect(client_street_address, '(no bog|no mor|old no)'),
      dplyr::case_when(
        # Single value without the proper prefix
        stringr::str_detect(client_street_address, '^(.+? [0-9]+) ([0-9]+)$') ~
          stringr::str_remove(
            client_street_address,
            stringr::str_match(
            client_street_address, 
            '^(.+? [0-9]+) ([0-9]+)$'
            )[,3]
          ),
        # Most values
        stringr::str_detect(
          client_street_address, 
          '^(.+?) ((?:no|number) ([0-9a-z]+))'
          ) ~ stringr::str_remove(
            client_street_address,
              stringr::str_match(
              client_street_address, 
              '^(.+?) ((?:no|number) ([0-9a-z]+))'
              )[,3]
            ), 
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Duplex

Previous cleaning and exploration had found several entries with a "duplex" component followed by a likely unit designation. We isolated the 3 observations that matched our potential suffix for manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(duplex)')
  )

nrow(checking)
# [1] 3
```

All three values were confirmed to be valid, and split per protocol. 

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy to Notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    ),
    # Extract Values
    client_street_address_scnd1_val = ifelse(
      case_id %in% checking$case_id,
      stringr::str_match(
          client_street_address, 
          '^(.+?) ((?:duplex) ([0-9a-z]+))'
          )[,4],
      client_street_address_scnd1_val
    ),
    # Remove unit/number values from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id,
        stringr::str_remove(
            client_street_address,
              stringr::str_match(
              client_street_address, 
              '^(.+?) ((?:duplex) ([0-9a-z]+))'
              )[,3]
            ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

We purged our checking subset for memory management.

```{r}
rm(checking)
```

#### Maximum Character Length (30 characters)

The maximum character length of the `client_street_address` field was 30 characters, indicating that values at this maximum length may have experienced truncation that might significantly influence the effectiveness of batch processing. We had 558 such entries, most of which appeared to be street names that were named in tribute to famous figures such as Martin Luther King Jr.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  )

nrow(checking)
# [1] 558
```

##### Martin Luther King Jr

The name "Martin Luther King Jr" is 21 characters in length, leaving little room for additional characters. We had 310 such rows. While various permutations of the name were examined, using AND logic for matches of "mart" and "king" appeared to catch all relevant values while minimizing any errant inclusions.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  ) |>
  dplyr::filter(
    stringr::str_detect(client_street_address, 'mart')  & stringr::str_detect(client_street_address, 'king')
  )

nrow(checking)
# [1] 310
```

We processed all entries. Care was given to maintain suffixes, where possible.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy to Notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    ),
    # Remove "DR" prefix from specific values
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        (stringr::str_starts(client_zip_code,'751')|
           stringr::str_starts(client_zip_code,'765')) &
        !stringr::str_ends(client_street_address, 'p'),
      stringr::str_replace(client_street_address, 'dr mart', 'mart'),
      client_street_address
    ),
    # Convert name to "mlk jr" for all values
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      stringr::str_replace(
        client_street_address, '(mart.+?)$', 'mlk jr'
        ),
      client_street_address
    ),
    # Add Street Suffixes
    client_street_address = ifelse(
      case_id %in% checking$case_id & !is.na(client_zip_code),
      dplyr::case_when(
        # ZIP 773, Special N/S designation
        (stringr::str_starts(client_zip_code,'773') & 
            stringr::str_detect(client_street_address, '04')
          ) ~ paste(client_street_address, 'pl n'),
        (stringr::str_starts(client_zip_code,'773') & 
            stringr::str_detect(client_street_address, '25')
          ) ~ paste(client_street_address,'pl s'),
        # 'HWY'
        stringr::str_starts(client_zip_code,'766') ~ 
          paste(client_street_address, 'hwy'),
        # 'ST'
        stringr::str_starts(client_zip_code,'778') ~ 
          paste(client_street_address, 'st'),
        # 'DR'
        (stringr::str_starts(client_zip_code, '776')|
           (stringr::str_starts(client_zip_code, '765') &
              stringr::str_detect(client_city, 'pl')
            )) ~ paste(client_street_address, 'dr'),
        # 'AVE'
        (stringr::str_starts(client_zip_code, '765') &
              stringr::str_detect(client_city, 'lt')
            ) ~ paste(client_street_address, 'ave'),
        (stringr::str_starts(client_zip_code, '756') &
              stringr::str_detect(client_street_address, '17')
            ) ~ paste(client_street_address, 'ave'),
        # 'BLVD'
        !stringr::str_ends(
          client_street_address, 
          '(hwy|blvd|ave|st|pl n|pl s|dr)'
          ) ~ paste(client_street_address, 'blvd'),
        TRUE ~ client_street_address
      ),
      client_street_address
      )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### "President"

There are many streets which are named after presidents, which include the "president" title. Such names are typically quite long, and prone to truncation. We identified 21 such entries in our data.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  ) |>
  dplyr::filter(
    stringr::str_detect(client_street_address, 'presi')
  )

nrow(checking)
# [1] 21
```

All such entries referenced the same road. To reduce insignificant string distancing, this road name was changed to only feature the highway's numerical name: "tx hwy 190". There was a single entry with an erroenous city, which was also corrected.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy to Notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    ),
    # Add "city" note to entry with erroneous city
    client_msc = ifelse(
      case_id %in% checking$case_id &
        stringr::str_starts(client_city, 'p'),
      paste0(client_msc, '; City: ', client_city),
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Convert City in single entry
    client_city = ifelse(
      case_id %in% checking$case_id &
        stringr::str_starts(client_city, 'p'),
      'richardson',
      client_city
    ),
    # Consolidate street name into "tx hwy 190"
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      stringr::str_replace(
        client_street_address,
        'pres(.+?)$',
        'tx hwy 190'
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Highway

Many truncated entries appeared to try to fully spell out "interstate highway", "texas state highway", and other long variations which consumed much of the text space. There were 55 values that contained references to "highway".

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  ) |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(high)')
  )

nrow(checking)
# [1] 55
```

We removed the terms "interstate", "state", and references to "access road" (which was impacted by truncation). The only state referenced was Texas, which we changed to the 2-character abbreviation to minimize nonsingificant string distancing.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy to Notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Remove "Interstate" and "State" Values
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '(interstate|state)'
        ),
      stringr::str_remove_all(
        client_street_address,
        '(interstate|state)'
      ),
      client_street_address
    ),
    # Remove references to access road
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '(acc|access rd|access r)$'
        ),
      stringr::str_remove_all(
        client_street_address,
        '(acc|access rd|access r)$'
      ),
      client_street_address
    ),
    # Convert "Texas" to "tx"
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '(texas)'
        ),
      stringr::str_replace(
        client_street_address,
        '(texas)',
        'tx'
      ),
      client_street_address
    ),
    # Convert "Highway" to "hwy"
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '(highway)'
        ),
      stringr::str_replace(
        client_street_address,
        '(highway)',
        'hwy'
      ),
      client_street_address
    ),
  ) |>
  dplyr::mutate(
    # Standardize white spaces to a single white space
    client_street_address = stringr::str_replace_all(
      client_street_address, "( {2,})", " "
      ),
    # Remove leading and trailing white spaces
    client_street_address = stringr::str_trim(
      client_street_address, side = 'both'
      )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Freeway

Similar to "highway", "freeway" had the potential for long names if spelled out completely. We had 3 such entries.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  ) |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(free)')
  )

nrow(checking)
# [1] 3
```

We standardized "freeway" to "fwy". We removed the references to "service r" (service road?) and "ap" (apartments?), which were lost due to truncation. 

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy to Notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Remove "Service Road" and "Apartment" values
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '( service r| ap)$'
        ),
      stringr::str_remove_all(
        client_street_address,
        '( service r| ap)$'
      ),
      client_street_address
    ),
    # Convert "freeway" to "fwy"
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(
          client_street_address, '(freeway)'
        ),
      stringr::str_replace(
        client_street_address,
        '(freeway)',
        'fwy'
      ),
      client_street_address
    ),
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### No Numbers

Use of the street address field as a comment box, entering full business names in this field, and other unusual entries may result in a lack of any numbers in the street address due to truncation. We had 4 such entries.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  ) |>
  dplyr::filter(
    !stringr::str_detect(client_street_address, '([0-9]+)')
  )

nrow(checking)
# [1] 4
```

Two entries were unable to be resolved, though one was able to have the city value updated. The other two entries had business names shifted to the `client_street_address_name` field, and addresses updated appropriately.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy to Notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Update City
    client_city = ifelse(
      case_id %in% checking$case_id &
        client_city == 'harris county',
      'houston',
      client_city
    ),
    # Remove unresolvable entries
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(bridge|intersection)'),
      NA_character_,
      client_street_address
    ),
    # Shift business names to name field
    client_street_address_name = ifelse(
      case_id %in% checking$case_id & !is.na(client_street_address),
      client_street_address,
      client_street_address_name
    ),
    # Update addresses
    client_street_address = ifelse(
      case_id %in% checking$case_id & !is.na(client_street_address),
      dplyr::case_when(
        stringr::str_detect(
          client_street_address, 
          'hope'
          ) ~ paste(
            '1', 
            stringr::str_match(client_street_address, '^(.+) home(?:.+)$')[,2],
            'way'
            ),
        stringr::str_detect(
          client_street_address, 
          'oaks'
          ) ~ '2003 w hutchins pl',
        TRUE ~ client_street_address
      ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Reference to Hotel/Inn/Lodging

Attempting to include a full business name for a hotel or inn was noted in the remaining truncated entries. We had 5 such entries.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  ) |>
  dplyr::filter(
    stringr::str_detect(client_street_address, '(inn|otel|suite)')
  )

nrow(checking)
# [1] 5
```

All entries referred to the same business. We adjusted the fields appropriately to resolve these entries.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
  dplyr::mutate(
    # Copy to Notes
    client_msc = ifelse(
      case_id %in% checking$case_id,
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # Shift business names to name field
    client_street_address_name = ifelse(
      case_id %in% checking$case_id,
      stringr::str_match(client_street_address,'^(.+) [0-9]')[,2],
      client_street_address_name
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id,
      paste0(
        stringr::str_match(client_street_address,'([0-9]+.+)$')[,2],
        'y 6'
        ),
      client_street_address
    )
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

##### Remaining Values at Maximum Length

There were 160 rows remaining with street address values at the maximum length (30 characters).

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_street_address) == 30
  )

nrow(checking)
# [1] 160
```

There were 19 variants (38 entries) which did not require any modification. One variant was not able to be fully resolved as it provided a directional address along a road which did not appear to exist as named; a best attempt was given to resolve as closely as possible, without losing data fidelity. 

There were entries that contained "farm to market", which was standardized to "ftm"; for one of these, the term "north" was additionally standardized to "n" to minimize non-significant string distancing. Another appeared to lose street name data due to truncation, which was corrected as best as the team was able using street mapping (Google Maps).

Other entries referenced counties by name, which were abbreviated to reduce non-significant string distances.

There were entries that referenced a county jail, a cemetery, and a care facility. These were updated to separate business names from street addresses, where possible.

The other entries required minor modifications, such as the standardization of a military ranking within a street name or re-introduction of truncated street name values less than 5 characters in length. A single entry had a city, state, and partial zip code removed.

```{r}
aps <- aps |>
  # Initiate subset-specific notes columns
  dplyr::mutate(
    client_msc = NA_character_ 
  ) |> 
    dplyr::mutate(
    # Copy to Notes if modifications made
    client_msc = ifelse(
      case_id %in% checking$case_id &
        (stringr::str_detect(client_street_address, 'on the') |
          stringr::str_detect(client_street_address, '4-north')|
          stringr::str_detect(client_street_address, '(market road fm 11)$')|
          stringr::str_detect(client_street_address, 'farm to market')|
          stringr::str_detect(client_street_address, 'van zandt county road')|
          stringr::str_detect(client_street_address, 'limestone county road')|
          stringr::str_detect(client_street_address, 'county jail')|
          stringr::str_detect(client_street_address, 'cemetery') |
          stringr::str_detect(client_street_address, 'village health')|
          stringr::str_detect(client_street_address, 'morgans p') |
          stringr::str_detect(client_street_address, 'io springs') |
          stringr::str_detect(client_street_address, 'w private') |
          stringr::str_detect(client_street_address, '(frontage ro)$') |
          stringr::str_detect(client_street_address, 'rosehl') |
          stringr::str_detect(client_street_address, 'kind jr') |
          stringr::str_detect(client_street_address, '(lla del)$') |
          stringr::str_detect(client_street_address, '( ci)$') |
          stringr::str_detect(client_street_address, '(le d)$') |
          stringr::str_detect(client_street_address, '(burg r)$') |
          stringr::str_detect(client_street_address, '(er blv)$') |
          stringr::str_detect(client_street_address, '(rns r)$') |
          stringr::str_detect(client_street_address, '(me s)$') | 
          stringr::str_detect(client_street_address, '(r pk)$') |
          stringr::str_detect(client_street_address, '(l bl)$') |
          stringr::str_detect(client_street_address, '(tx [0-9]{2})$')
          ),
      client_street_address,
      client_msc
    )
  ) |>
  dplyr::mutate(
    # "Best possible" attempt to fix unresolvable value
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'on the'),
      paste(
        stringr::str_match(client_street_address, '^([0-9]+)'),
        'main st'
        ),
      client_street_address
    ),
    # Standardize Farm to Market Values
    ## First, catch the "#-north" value
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, '4-north'),
      stringr::str_replace(
        client_street_address,
        '4-north',
        '4 n'
      ),
      client_street_address
    ),
    ## Second, fix truncated entry (confirmed via google maps)
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, '(market road fm 11)$'),
      paste0(
        client_street_address,
        '01'
        ),
      client_street_address
    ),
    ## Third, standardize the 'farm to market' values
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'farm to market'),
      stringr::str_replace(
        client_street_address,
        paste0(
          '(farm to market road fm|farm to market road|',
          'farm to market fm|farm to market)'),
        'ftm'
      ),
      client_street_address
    ),
    # County Roads with County Name
    ## First, catch "Van Zandt" County Roads
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'van zandt county road'),
      stringr::str_replace(
        client_street_address,
        'van zandt county road',
        'vz-cr '
      ),
      client_street_address
    ),
    ## Second, catch "Limestone" County Roads
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'limestone county road'),
      stringr::str_replace(
        client_street_address,
        'limestone county road',
        'l-cr'
      ),
      client_street_address
    ),
    # Business names in street addresses
    ## First, catch county jail
    client_street_address_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'county jail'),
      stringr::str_match(client_street_address,  '^((.+?)(county jail))')[,2],
      client_street_address_name
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'county jail'),
      stringr::str_match(client_street_address, '(county jail )(.+?)$')[,3],
      client_street_address
    ),
    ## Second, catch cemetery
    client_street_address_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'cemetery'),
      stringr::str_match(
        client_street_address, 
        '^([0-9]+) ((.+?)(cemetery))'
        )[,3],
      client_street_address_name
    ),
    client_city = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'cemetery'),
      'hearne',
      client_city
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'cemetery'),
      stringr::str_remove(
        client_street_address,
        stringr::str_match(
          client_street_address, 
          '^([0-9]+) ((.+?)(cemetery))'
          )[,3]
        ),
      client_street_address
    ),
    # Third, catch health facility
    client_street_address_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'village health'),
      stringr::str_match(
        client_street_address, 
        '^([0-9]+) ((.+?)(village health))$'
        )[,3],
      client_street_address_name
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_street_address, 'village health'),
      stringr::str_replace(
        client_street_address,
        'village health',
        'dr'
      ),
      client_street_address
    ),
    # Remove regional/resort names from street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'morgans p'),
      stringr::str_match(client_street_address, '^(.+?)(morgans p)')[,2],
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'io springs'),
      stringr::str_remove(
        client_street_address,
        'springs'
      ),
      client_street_address
    ),
    # Standardize military ranking in street address
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'w private'),
      stringr::str_replace(
        client_street_address,
        'lan',
        'st'
      ),
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'w private'),
      stringr::str_replace(
        client_street_address,
        'private',
        'pvt'
      ),
      client_street_address
    ),
    # Remove unnecessary mention of frontage road
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(frontage ro)$'),
      stringr::str_remove(
        client_street_address,
        ' frontage ro'
      ),
      client_street_address
    ),
    # Fix error in street name
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'rosehl'),
      stringr::str_replace(
        client_street_address,
        'rosehl',
        'rosehill'
      ),
      client_street_address
    ),
    # Adjust localized street name to valid street name
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, 'kind jr'),
      paste0(
        stringr::str_match(
          client_street_address,
          '^([0-9]+? )(.+?)kind jr'
        )[,2],
        'e hwy 80'
      ),
      client_street_address
    ),
    # Add missing suffix to street name
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(lla del)$'),
      paste(client_street_address, 'sol'),
      client_street_address
    ),
    # Add missing portions of street name suffixes
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        (stringr::str_detect(client_street_address, '( ci)$')|
        stringr::str_detect(client_street_address, '(le d)$')),
      paste0(client_street_address, 'r'),
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        (stringr::str_detect(client_street_address, '(burg r)$')|
        stringr::str_detect(client_street_address, '(er blv)$')|
        stringr::str_detect(client_street_address, '(rns r)$')),
      paste0(client_street_address, 'd'),
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(me s)$'),
      paste0(client_street_address, 't'),
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(r pk)$'),
      paste0(client_street_address, 'wy'),
      client_street_address
    ),
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(l bl)$'),
      paste0(client_street_address, 'vd'),
      client_street_address
    ),
    # Remove city, state, and partial zip code
    client_street_address = ifelse(
      case_id %in% checking$case_id &
        stringr::str_detect(client_street_address, '(tx [0-9]{2})$'),
      stringr::str_match(
        client_street_address, 
        '^(.+? st)(.+? tx [0-9]{2})$'
        )[,2],
      client_street_address
    ),
  ) |>
  dplyr::mutate(
  # Shift notes data into overall client notes field
    client_notes = ifelse(
      # If client_notes has no text, just add client_msc (if not empty)
      is.na(client_notes),
      ifelse(!is.na(client_msc),
        paste("Street Addr:", client_msc),
        client_notes),
      # Otherwise, paste if client_notes exists to avoid pasting "NA" in 
      # anything
      ifelse(
        !is.na(client_msc),
        paste(client_notes, "; Street Addr:", client_msc),
        client_notes
      )
    )
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc))
```

# üíæ

```{r}

```

