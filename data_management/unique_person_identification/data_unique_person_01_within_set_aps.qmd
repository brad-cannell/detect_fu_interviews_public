---
title: "Cleaning APS"
html:
  embed-resources: true
format: html
---

# ‚≠êÔ∏è Overview

The APS records data set was divided into 5 separate, interconnected excel files. These files (WILL BE) documented in the [wiki](https://github.com/brad-cannell/detect_fu_interviews_public/wiki). The primary file of interest for subject-level linkage is the "Clients.xlsx" file. This file contained 568,562 observations of 11 variables, including 378,418 values for `client_id`.


## Data Wrangling

-   Placeholder

    -   Placeholder

## Data Cleaning

-   Placeholder

# üì¶ Load Packages and Functions

## Library Imports

```{r, warning = FALSE}

suppressPackageStartupMessages({
  library(tidyverse)
  library(readxl)
  library(here)
  library(data.table)
})

```

## Functions

```{r}
# Function to consolidate and count unique values found in variable(s)
source(here::here("r", "get_unique_value_summary.R"))
```


Placeholder

# üì• Load Data

## APS "Client.xlsx"

APS client data was loaded for processing from XLSX format. Data types were specified for key fields to minimize loss of data, such as in date formats. We also standardized variable naming into lowercase, replacing spaces with underscores and eliminating "\r\n" elements of names (which represent Microsoft Formatting).

We anticipated an error in row 144,102 for column C ("Client ID") as the Excel document has it listed as "blank".

```{r}
aps_path <- here::here("data","DETECT Shared with APS","Clients.xlsx")
aps <- readxl::read_excel(aps_path,
                  sheet = "Client Detail",
                  col_types = c(
                    "numeric", "numeric", "date", rep("text",8)
                    )
                  ) |>
       dplyr::rename_with( ~ tolower(gsub(" ", "_", .x, fixed = TRUE))) |>
       dplyr::rename_with( ~ tolower(gsub("\r\n", "", .x, fixed = TRUE)))

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "APS data imported with", nrow(aps), "rows and", ncol(aps), "columns.\n",
  "Data last modified on OneDrive",
  as.character(file.info(aps_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (aps_path)


# Warning: Expecting numeric in B144102 / R144102C2: got 'blank'
# 2024-05-08: APS data imported with 568562 rows and 11 columns.
# Data last modified on OneDrive 2024-03-21 18:35:52 
```

## USPS Zip Code Validation Data

The United States Postal Service releases an Excel file detailing ZIP Codes with their associated Area and District Codes. This includes State data for a State-level verification of Zip Code values. This file used the version obtained on the [USPS website](https://postalpro.usps.com/ZIP_Locale_Detail), last updated May 03, 2024.

```{r}
usps_path <- here::here("data","USPS_ZIP_Locale_Detail.xls")
usps_zip <- readxl::read_excel(usps_path,
  # Select only the desired data
                  col_types = c(
                    rep("skip", 4), "text", rep("skip", 2), rep("text", 3),
                    "skip"
                    ),
                  col_names = c(
                    'delivery_zip', 'city', 'state', 'phys_zip'
                    ),
                  # skips row of headers
                  skip = 1
                  ) |>
  # Remove rows with duplicated rows
  dplyr::distinct()

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "USPS Zip Code data imported with", nrow(usps_zip), "rows and", ncol(usps_zip), "columns.\n",
  "Data last modified on OneDrive",
  as.character(file.info(usps_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (usps_path)


# 2024-05-08: USPS Zip Code data imported with 43307 rows and 4 columns.
# Data last modified on OneDrive 2024-05-06 14:48:02 
```

We performed a modification of the USPS data so that it acted as a dictionary, with the zip code as the unique key.

```{r}
# Alter data so that ZIP CODE acts as a key, indicating the state associated
# with each ZIP CODE for Delivery (service) area and Physical (actual
# location of service delivery) for each ZIP CODE.

usps_zip <- dplyr::full_join(
  # Isolate State for Each Physical Zip Code
  usps_zip |>
    dplyr::select('state', 'phys_zip') |>
    dplyr::distinct() |>
    dplyr::rename_at(
      c('state', 'phys_zip'),
      ~c('usps_state_phys', 'client_zip_code')
    ) |>
    # Change value for any repeated Zip Code (multiple States for Physical)
    # so that each Zip is only present once
    dplyr::mutate(usps_state_phys = ifelse(
      (
        duplicated(client_zip_code)|
        duplicated(client_zip_code, fromLast = TRUE)
       ),
       'Multiple',
       usps_state_phys
      )
      ) |>
    dplyr::distinct(),
  # Isolate State for Each Delivery Zip Code
  usps_zip |>
    dplyr::select('state', 'delivery_zip') |>
    dplyr::distinct() |>
    dplyr::rename_at(
      c('state', 'delivery_zip'),
      ~c('usps_state_delivery', 'client_zip_code')
    ) |>
    # Change value for any repeated Zip Code (multiple States for Physical)
    # so that each Zip is only present once
    dplyr::mutate(usps_state_delivery = ifelse(
      (
        duplicated(client_zip_code)|
          duplicated(client_zip_code, fromLast = TRUE)
        ),
       'Multiple',
       usps_state_delivery
      )
      ) |>
    dplyr::distinct(),
  by = 'client_zip_code'
)
```


# Initial Data Structure

## APS Data

The APS client data set contained 568,562 observations for 11 variables.

```{r}
dim(aps)

# [1] 568562     11
```

This included 378,418 unique Client ID values, which should be unique to each subject.

```{r}
length(unique(aps$client_id))

# [1] 378418
```

There was only one observation which was missing a value for Client ID, which was anticipated (was entered as "blank" in original Excel document).

```{r}
nrow(aps |>
       dplyr::filter(is.na(aps$client_id))
     )

# [1] 1
```

Per APS documentation (see notes documents in data folders), each APS Case should have one Client ID (Clients may have more than one Case, each Case only has one client, One-to-Many relationship of Client-Case). The data set initially included 568,385 values for Case ID, indicating some Case IDs possibly represented more than one observation (and thus possibly more than one Client ID was assigned to a Case ID).

```{r}
length(unique(aps$case_id))

# [1] 568385
```

There were 290,004 observations that contained a duplicated Client ID.

```{r}
nrow(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         )
     )

# [1] 290004
```

This represented 99,860 Client IDs and 289,975 Case IDs.

```{r}
cat("Client IDs:", 
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         ) |>
         dplyr::select(client_id)
      )),
    ";", "Case IDs:",
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         ) |>
         dplyr::select(case_id)
      ))
    )

# Client IDs: 99860 ; Case IDs: 289975
```

There were 351 observations that contained a duplicated Case ID.

```{r}
nrow(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         )
     )

# [1] 290004
```

This represented 99,860 Client IDs and 289,975 Case IDs. This indicated likely "failed matches" (one subject represented by more than one Client ID), likely due to human/system error in data entry.

```{r}
cat("Client IDs:", 
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         ) |>
         dplyr::select(client_id)
      )),
    ";", "Case IDs:",
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         ) |>
         dplyr::select(case_id)
      ))
    )

# Client IDs: 349 ; Case IDs: 174
```

There were 27,161 unique values in the field for first names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_first_name') |>
  dplyr::arrange(value) |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 27161
```

There were 7,588 unique values in the field for middle names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_middle_name') |>
  dplyr::arrange(value) |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 7588
```

There were 57,846 unique values in the field for middle names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_last_name') |>
  dplyr::arrange(value) |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 57846
```

# Data Validation and Modification

Data required some validation and modification to maximize returns from fastLink processing. First, all leading and trailing white space was removed from any string values, and values were converted to lowercase.

```{r}
aps <- aps |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~tolower(stringr::str_trim(., side = 'both'))
                ))
```

We also reduced any instances of multiple white spaces ("  ") into a single white space, for consistency.

```{r}
aps <- aps |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~stringr::str_replace_all(.x, "( {2,})", " ")
                ))
```


## Name Fields

Names values were already separated into First, Middle Initial, and Last.

### "Unknown"

We inspected name values for "Unknown", a common placeholder that is better represented by a missing value. We found 75 observations with a potential value for "Unknown" in at least one name field.

```{r}
target_regex <- "(unkn)|(don't)|(homel)|(unk\\.)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 75
```

Several of these observations had potentially valuable information for subject matching, specifically "male" or "female" in one of the name fields along with a value for "unknown". We shifted these gender values into a notes column, and converted those values to missing (`NA`) values.

```{r}
aps <- aps |>
  # Initiate columns
  dplyr::mutate(
    client_msc = NA_character_, 
    client_msc_first = NA_character_,
    client_msc_last = NA_character_,
    client_msc_middle = NA_character_
  ) |>
  # Shift from first, middle, and last name field to a notes column
  dplyr::mutate(
    # Shift "male" or "female" from first name to notes field
    client_msc_first = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_first_name == 'male' ~ 'male', 
        client_first_name == 'female' ~ 'female',
        TRUE ~ client_msc_first
      ),
      client_msc_first),
    client_first_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_first_name == 'male' ~ NA_character_,
        client_first_name == 'female' ~NA_character_,
        TRUE ~ client_first_name
      ),
      client_first_name
      )
  ) |>
  dplyr::mutate(
    # Shift "male" or "female" from Middle name to notes field
    client_msc_middle = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_middle_name == 'male' ~ 'male', 
        client_middle_name == 'female' ~ 'female',
        TRUE ~ client_msc_middle
      ),
      client_msc_middle),
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_middle_name == 'male' ~ NA_character_,
        client_middle_name == 'female' ~NA_character_,
        TRUE ~ client_middle_name
      ),
      client_middle_name
      )
  ) |>
  dplyr::mutate(
    # Shift "male" or "female" from last name to notes field
    client_msc_last = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_last_name == 'male' ~ 'male', 
        client_last_name == 'female' ~ 'female',
        TRUE ~ client_msc_last
      ),
      client_msc_last),
    client_last_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_last_name == 'male' ~ NA_character_,
        client_last_name == 'female' ~NA_character_,
        TRUE ~ client_last_name
      ),
      client_last_name
      )
  ) |>
  # Collect data into a single, neat notes column with NAs omitted
  dplyr::mutate(
    client_msc = paste(
      client_msc_first, client_msc_middle, client_msc_last, 
      sep = "; "
      ),
    client_msc = stringr::str_remove_all(client_msc, "NA; "),
    client_msc = stringr::str_remove_all(client_msc, "; NA"),
    client_msc = stringr::str_remove_all(client_msc, "NA"),
    client_msc = ifelse(client_msc == '', NA_character_, client_msc)
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc_first, client_msc_middle, client_msc_last))
```

A point-fix was utilized to correct the only entry with "don't know" in a name field.

There were also several observations that contained "unknown" in one name field with either "person" or "ward" as the only other potentially informative value, both of which were better expressed as missing (`NA`) values in this context. There were no names such as "Edward" that would otherwise be valid but caught in our regular expressions within this set. üî¥ Any modification to this data processing pipeline should include verification that this is still true to avoid loss of valuable data.

```{r}
aps <- aps |>
  # "don't know" in middle name
  dplyr::mutate(
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      ifelse(
        client_middle_name == "don't know",
        NA_character_,
        client_middle_name
      ),
      client_middle_name
      )
  ) |>
    # Remove names that are "person" or "ward" that were caught in "Unknown"
    # name checks
  dplyr::mutate(
    # First name
    client_first_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_first_name, '(person)') ~ NA_character_, 
        stringr::str_detect(client_first_name, '(ward)') ~ NA_character_,
        TRUE ~ client_first_name
      ),
      client_first_name),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_middle_name, '(person)') ~ NA_character_,
        stringr::str_detect(client_middle_name, '(ward)') ~NA_character_,
        TRUE ~ client_middle_name
      ),
      client_middle_name
      ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_last_name, '(person)') ~ NA_character_,
        stringr::str_detect(client_last_name, '(ward)') ~NA_character_,
        TRUE ~ client_last_name
      ),
      client_last_name
      )
  )
```

We were then able to set any of our "unknown" name values to missing values, maintaining helpful data.

```{r}
aps <- aps |> 
  dplyr::mutate(
    client_first_name = ifelse(
      stringr::str_detect(client_first_name, target_regex),
      NA_character_,
      client_first_name
    ),
    client_middle_name = ifelse(
      stringr::str_detect(client_middle_name, target_regex),
      NA_character_,
      client_middle_name
    ),
    client_last_name = ifelse(
      stringr::str_detect(client_last_name, target_regex),
      NA_character_,
      client_last_name
    )
  )
```

We additionally identified 8 rows with a name value of "none". We isolated these observations for manual examination.

```{r}
target_regex <- "^(none)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 8
```

We determined that all of the "none" values likely represented an "unknown" value, and converted those values to missing values.

```{r}
aps <- aps |> 
  dplyr::mutate(
    client_first_name = ifelse(
      stringr::str_detect(client_first_name, target_regex),
      NA_character_,
      client_first_name
    ),
    client_middle_name = ifelse(
      stringr::str_detect(client_middle_name, target_regex),
      NA_character_,
      client_middle_name
    ),
    client_last_name = ifelse(
      stringr::str_detect(client_last_name, target_regex),
      NA_character_,
      client_last_name
    )
  )
```

Due to the US convention of naming unknown subjects "Jane Doe" or "John Doe", we checked for rows where the last name was "doe". These 6 rows were isolated for manual review. All appeared to be potentially valid instances of a subject with the last name of "Doe", rather than an anonymous placeholder.

```{r}

checking <- aps |> 
  dplyr::filter(
    client_last_name == 'doe'
    )

nrow (checking)

# [1] 6
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

### Numbers in Names

In previous checks, several name fields were identified which had numbers rather than name data. Names do not typically contain numerical digits, but numerical digits may frequently occur as a typographical or system error in entry. We isolated 11 entries with a numerical digit in any name field.

```{r}
target_regex <- "([0-9]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 11
```

There were two observations that merited a point-fix to shift potentially useful data into our new notes field.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Subject with a name of "trailer #10"
    client_msc = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      'trailer #10',
      client_msc
      ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      NA_character_,
      client_first_name
      ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      NA_character_,
      client_last_name
      ),
    # Possibly important numbers in a last name
    client_msc = ifelse(
      case_id %in% checking$case_id & client_last_name == "44947",
      '44947',
      client_msc
      ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "44947",
      NA_character_,
      client_last_name
      )
  )
```


Numbers were otherwise omitted from all name fields. Empty strings were converted into missing values.

```{r}
 aps <- aps |>
  dplyr::mutate(
    client_first_name = stringr::str_remove_all(
      client_first_name, target_regex
      ),
    client_middle_name = stringr::str_remove_all(
      client_middle_name, target_regex
      ),
    client_last_name = stringr::str_remove_all(
      client_last_name, target_regex
      )
  ) |>
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

### Unexpected Characters (non A-Z or a-z)

We expected most, if not all, names in our subset to consist only of the letters A-Z without special characters, punctuation, or other characters.

#### Hyphens (-)

The most common character we expected to be validly present was a hyphen (-), due to traditions of hyphenating names. We isolated 4,785 entries with a hyphen in any name field for manual review.

```{r}
target_regex <- "([-]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 4785
```
 
While all 4,785 observation had a valid use of hyphens, some modification was still required due to the inconsistent use of white space with hyphenated names (i.e. Smith-Jones as "smith- jones", "smith -jones", or "smith-jones"). As such, we stripped white space surrounding hyphens from observations in our data set. This was complicated due to valid use of hyphens and spaces in multi-part names (e.g. "de la cruz- smith") in first and last name fields.
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, ' -', '-'),
      client_first_name
    ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, '- ', '-'),
      client_first_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, ' -', '-'),
      client_last_name
    ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, '- ', '-'),
      client_last_name
    )
  )
```

We checked for any instances with more than one consecutive hyphen ("--", etc.) after the initial corrections. We isolated the 8 observations for manual review.

```{r}
target_regex <- "(-{2,})"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 8
```

The instances of multiple hyphens all appeared within last name values. We adjusted these entries to ensure only a single hyphen was present.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, '-'),
      client_last_name
    )
  )
```

We checked for any instances where a hyphen was the first character in the field. We identified 0 occurrences.

```{r}
target_regex <- "^(-)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 0
```

We checked for any instances where a hyphen was the last character in the field. We identified 4 occurrences.

```{r}
target_regex <- "(-)$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 4
```

We adjusted these entries to trim the trailing hyphen.

```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, target_regex, ''),
      client_first_name
    ),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, target_regex, ''),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, ''),
      client_last_name
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Double Quote (") and quote-surrounded nicknames.
 
Several subjects appeared to have names in double quotation marks, particularly in the middle name field. These values were likely to represent nicknames or aliases. We isolated 14 entries with names surrounded by double-quotes, present in both the first and middle name fields.

```{r}
target_regex <- '(["]+)'

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 14
```
 
We shifted these likely nickname values into our notes field, and removed them from the name fields. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, '(".*?")'),
      client_msc
    ),
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, '(".*?")'),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, '(".*?")'),
      client_middle_name
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, '(".*?")'),
      client_first_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```
 
We assessed for similar entries using single quotes rather than double quotes, and found a single observation with a single quote nickname in the first name field.

```{r}
target_regex <- "('.*?')+"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 1
```

We shifted this likely nickname values into our notes field, and removed it from the name field. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, "('.*?')"),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, "('.*?')"),
      client_first_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We assessed for similar entries using parentheses rather than double quotes, and found two observations with a parenthesis surrounded nickname (first name and middle name fields)

```{r}
target_regex <- "(\\(.*?\\))+"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 2
```

We shifted these likely nickname values into our notes field, and removed them from the name fields. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, "(\\(.*?\\))"),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, "(\\(.*?\\))"),
      client_first_name
    ),
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, "(\\(.*?\\))"),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, "(\\(.*?\\))"),
      client_middle_name
    ), 
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

In the examination of name values, we also identified a single nickname that appeared to be indicated in the middle name field, preceded by "goes by". We isolated this observation for further evaluation.

```{r}
target_regex <- "goes by (.*)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 1
```

We shifted this likely nickname value into our notes field, and removed it from the middle name field. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, "goes by (.*)"),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, "goes by (.*)"),
      client_middle_name
    ), 
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Single Quotes (')

Single quotes (') may be valid and commonly present in some names, such as in Irish and Scottish conventions (e.g. "O'Brien"). We isolated 682 entries with a single quote in any name field for manual review. 

```{r}
target_regex <- "([']+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 681
```

While most occurrences of single quotes appeared to be valid, modification was still required due to the inconsistent use of white space with single quotes in names (i.e. O'Brien as "o'brien", "o' brien", "o 'brien", or "o ' brien"). As such, we stripped white space surrounding single quotes from observations in our data set. This was complicated due to valid use of hyphens and spaces in multi-part names (e.g. "de la cruz- smith") in the name fields.

Additionally, we were unable to correct for what appeared to be usage of a single quote when a hyphen was appropriate (i.e. "Smith-Jones" as "smith'jones") due to the complexity of generating a solution without sizable point-fixes with small potential benefit to string-matching after correction.
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, " '", "'"),
      client_first_name
    ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, "' ", "'"),
      client_first_name
    ),
  # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, " '", "'"),
      client_middle_name
    ),
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, "' ", "'"),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, " '", "'"),
      client_last_name
    ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, "' ", "'"),
      client_last_name
    )
  )
```

We checked for any instances where a single quote was the first character in the field. We identified no occurrences.

```{r}
target_regex <- "^(')"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 0
```

We checked for any instances where a single quote was the last character in the field. We identified 13 occurrences.

```{r}
target_regex <- "(')$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 13
```

We adjusted these entries to trim the trailing single quote.

```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, target_regex, ''),
      client_first_name
    ),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, target_regex, ''),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, ''),
      client_last_name
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Examination for suffixes

JR and SR are common suffixes to names, but may artificially increase string-distance. We isolated 157 entries with a potential suffix match in any name field for manual review. 

```{r}
target_regex <- "((junior)|(senior)|(jr)|(sr))[^a-z]?$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 157
```

Suffix items appeared in all fields. Values were shifted from middle name and last name fields, but left in first name fields as these are also possible initial-isms or otherwise valid first names.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, target_regex),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, target_regex),
      client_middle_name
    ),
    # Extract from Last Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_match(client_last_name, target_regex),
      client_msc
    ),
    # Remove from Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_remove(client_last_name, target_regex),
      client_last_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Potential titles in name fields

Mr., Ms., Mrs., and Dr. are the primary titles used in the US. Sr. and Sra. are common Spanish-language titles used in the US. We isolated 14 potential occurrences for manual review.

```{r}
target_regex <- paste0(
  "^((doctor)|(mister)|(misus)|(miss)|(mrs)|(senora)|",
  "(senorita)|(senora)|(sra)|(ms)|(mr)|(sr)|(dr))(?![a-z]+)"
  )

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 14
```

All 11 potential titles were found in first name fields. Extraction was complicated by additional values within the field that were valuable (example: first name of "mr. smith" with no value in middle or last name fields) and values which simply required trimming (example: first name of "dr. john" with last name value of "doe").

First, we shifted desired values to our note ("client_msc") variable.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, target_regex),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, target_regex),
      client_first_name
    )
  )
```

Then, we identified our single row where there was no additional last name name information.

```{r}
target_row <- pull(aps |>
  dplyr::filter(
    (case_id %in% checking$case_id) & is.na(client_last_name)
    ) |>
  dplyr::select(case_id)
  )
```

We shifted the remaining information in the targeted observation's first name field into the last name field.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_last_name = ifelse(
      (case_id %in% checking$case_id &
        case_id == target_row),
      str_extract(client_first_name, "\\. ([a-z]+)"),
      client_last_name
    ),
    client_first_name = ifelse(
      (case_id %in% checking$case_id &
        case_id == target_row),
      NA_character_,
      client_first_name
    )
  )
```

We purged our checking subset, target regular expression, and target_row values for memory management.

```{r}
rm(checking)
rm(target_regex)
rm(target_row)
```

#### Removal of other unexpected characters

Any characters other than single quotes, hyphens, white spaces, or alphanumeric characters were no longer anticipated to be valid. We additionally set the Spanish Language character "√±" as acceptable. We isolated 2,254 potential occurrences for manual review.

```{r}
target_regex <- "([^a-z√± '-])"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 2254
```

On review, all remaining unanticipated characters to a single white space, across all name fields.

```{r}
aps <- aps |>
  # Convert non-anticipated punctuation to white space
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(
                    case_id %in% checking$case_id,
                    stringr::str_replace_all(.x, target_regex, ""),
                    .x
                    )
                  )
                )
```

We then performed cleaning: multiple white spaces were converted to a single white space; leading and trailing white spaces were trimmed; and empty strings were converted to missing values.

```{r}
aps <- aps |>
  # Trim multiple white spaces to single white space
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(
                    case_id %in% checking$case_id,
                    stringr::str_replace_all(., "( {2,})", " "),
                    .
                    )
                  )
                ) |>
  # Trim leading and trailing white spaces
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~stringr::str_trim(., side = 'both')
                  )
                ) |>
  # Convert empty strings to missing values
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(. == '', NA_character_, .)
                  )
                ) 
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

## Address Fields



### Zip Codes

We expected ZIP codes to follow a 5-digit format. Many entries contained a 5+4 format (10 character, #####-#### format). Only 7 entries did not directly match either format. These were manually reviewed.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_zip_code) < 10) |>
  dplyr::filter(nchar(client_zip_code) != 5)

nrow(checking)

# [1] 7
```

4 Zip Codes were otherwise valid, but had leading zeros truncated by Excel. These were fixed by re-adding the leading zeroes to the string value for the zip code

```{r}
aps <- aps |>
  # Add leading 0s to truncated Zip Codes.
  dplyr::mutate(client_zip_code = dplyr::case_when(
    nchar(client_zip_code) == 3 ~ paste0("00", client_zip_code),
    nchar(client_zip_code) == 4 ~ paste0("0", client_zip_code),
    TRUE ~ client_zip_code)
    ) 
```

The remaining 3 observations appeared to be fixable by truncating to 5 digits, along with the remainder of the data set's 10 character values:

-   1 Zip Code had 5 digits which appeared to be otherwise valid, with a hyphen ("-") and no 4 digit addition to the zip code. This was fixed by truncating the hyphen so only the first 5 digits were kept.

-   2 Zip Codes had all 9 digits, but without the anticipated hyphen between the 5 and 4 digit components of zip code. These were fixed by truncating so only the first 5 digits were kept.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_zip_code = ifelse(
      nchar(client_zip_code)>5,
      substr(client_zip_code, start=1, stop=5),
      client_zip_code)
  )
```

We performed a state-level verification of Zip Code data using the USPS Zip Code service data. We identified 130 observations where the Client State did not match either the USPS physical or delivery service areas based on the Zip Code.

```{r}
checking <- aps %>%
  tibble::add_column(
    usps_state_phys = NA_character_, 
    usps_state_delivery = NA_character_
    ) |>
  # Add USPS data
  dplyr::rows_update(
    usps_zip, 
     by = "client_zip_code", 
     unmatched = "ignore"
  ) |>
  # Flag mismatches between USPS and APS state based on zip code
  dplyr::mutate(
    flag_physical_zip = dplyr::case_when(
      is.na(usps_state_phys) ~ FALSE,
      (!is.na(usps_state_phys) & !is.na(client_state)) & 
        (usps_state_phys == client_state) ~
        FALSE,
      (is.na(usps_state_phys) & is.na(client_state)) ~ FALSE,
      TRUE ~ TRUE
    ),
    flag_delivery_zip = dplyr::case_when(
      is.na(usps_state_delivery) ~ FALSE,
      (!is.na(usps_state_delivery) & !is.na(client_state)) & 
        (usps_state_delivery == client_state) ~
        FALSE,
      (is.na(usps_state_delivery) & is.na(client_state)) ~ FALSE,
      TRUE ~ TRUE
    ),
    flag_zip = ifelse(flag_physical_zip | flag_delivery_zip, TRUE, FALSE),
    # If it matched either physical or delivery, unflag the row
    flag_zip = dplyr::case_when(
      !is.na(usps_state_phys) & !flag_physical_zip ~ FALSE,
      !is.na(usps_state_delivery) & !flag_delivery_zip ~ FALSE,
      TRUE ~ flag_zip
    )
  ) |>
  # Extract only the flagged observations
  dplyr::filter(flag_zip) |>
  # Reorder variables for ease of manual checking
  dplyr::relocate(
    flag_zip, flag_physical_zip, flag_delivery_zip, client_zip_code,
    usps_state_phys, usps_state_delivery,
    client_city, client_county, client_state, client_street_address
    ) |>
  dplyr::arrange(client_zip_code)

nrow(checking)

# [1] 130
```

Manual review involved searching for street addresses (if provided) using Google Maps and comparison against remainder of the APS provided address data fields. The vast majority of point fixes involved an minor typographical error, or unusual entry of data (such as states within city fields). 

Point-fixes were made by calling data from the "checking" subset to avoid overwriting other entries with identical values for Case ID that were not flagged for manual review, minimizing collateral changes to the data.

There were 87 observations that were deemed to require no revision, largely due to ZIP codes that were along state borders (thus postal service crossed state lines for the given location). There were 6 observations with issues that were unable to be resolved, largely due to missing street addresses and/or conflicting results when searching for a reliable match. There were 37 observations that received point-fixes.

```{r}
# ZIP 28207 to 78207 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '28207') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78207'

# ZIP 32667 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '32667') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_


# ZIP 46502 to 76502 (3 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '46502') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76502'


# Entry for ZIP 48202 to City "DETROIT", State "MI", 
#county "OUT OF STATE" (2 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_city'] <- 'detroit'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'mi'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

# ZIP 64114 to 77831 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '64114') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '77831'

# ZIP 67026 to 76028 (3 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '67026') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76028'

# Entry for ZIP 70125 State to "LA" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70125') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'la'

# ZIP 70526 to 78526 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70526') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78526'

# ZIP 70602  to 76579 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70602') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76579'

# Entry for ZIP 73840 to 71854, state "AR", County "OUT OF STATE" (3 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'ar'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '71854'


# ZIP 74067 to 78067 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74067') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78067'

# ZIP 74543 to 78543 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74543') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78543'

# ZIP 74756 state to OK (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74756') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'ok'

# ZIP 78368 to a missing value (4 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78368') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# Entry for ZIP 78595 state "TX", county to a missing value (4 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78595') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'tx'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78595') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- NA_character_

# Entry for ZIP 80102 to 79045, county to "DEAF SMITH" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80102') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'deaf smith'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80102') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '79045'

# ZIP 80134 to 76201 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80134') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76201'

# Entry for ZIP 82331 state to "WY" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '82331') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'wy'

# Entry for ZIP 87575 state to 'NM', county to 'OUT OF STATE' (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '87575') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'nm'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '87575') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

# Entry for ZIP 88063 state to "NM" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '88063') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'nm'

# ZIP 88125 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '88125') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# ZIP 89420 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '89420') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# ZIP 97524 to 78852 (2 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '97524') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78852'

```

We purged the USPS ZIP code data and our checking subset for memory management.

```{r}
rm(usps_zip)
rm(checking)
```




```{r}

```

# üíæ
