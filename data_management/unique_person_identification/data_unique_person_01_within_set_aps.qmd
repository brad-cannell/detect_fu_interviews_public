---
title: "Cleaning APS"
html:
  embed-resources: true
format: html
---

# ‚≠êÔ∏è Overview

The APS records data set was divided into 5 separate, interconnected excel files. These files (WILL BE) documented in the [wiki](https://github.com/brad-cannell/detect_fu_interviews_public/wiki). The primary file of interest for subject-level linkage is the "Clients.xlsx" file. This file contained 568,562 observations of 11 variables, including 378,418 values for `client_id`.


## Data Wrangling

-   Placeholder

    -   Placeholder

## Data Cleaning

-   Placeholder

# üì¶ Load Packages and Functions

## Library Imports

```{r, warning = FALSE}

suppressPackageStartupMessages({
  library(tidyverse)
  library(readxl)
  library(here)
  library(data.table)
  library(rvest)
})

```

## Functions

```{r}
# Function to consolidate and count unique values found in variable(s)
source(here::here("r", "get_unique_value_summary.R"))
```


Placeholder

# üì• Load Data

## APS "Client.xlsx"

APS client data was loaded for processing from XLSX format. Data types were specified for key fields to minimize loss of data, such as in date formats. We also standardized variable naming into lowercase, replacing spaces with underscores and eliminating "\r\n" elements of names (which represent Microsoft Formatting).

We anticipated an error in row 144,102 for column C ("Client ID") as the Excel document has it listed as "blank".

```{r}
aps_path <- here::here("data","DETECT Shared with APS","Clients.xlsx")
aps <- readxl::read_excel(aps_path,
                  sheet = "Client Detail",
                  col_types = c(
                    "numeric", "numeric", "date", rep("text",8)
                    )
                  ) |>
       dplyr::rename_with( ~ tolower(gsub(" ", "_", .x, fixed = TRUE))) |>
       dplyr::rename_with( ~ tolower(gsub("\r\n", "", .x, fixed = TRUE)))

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "APS data imported with", nrow(aps), "rows and", ncol(aps), "columns.\n",
  "Data last modified on OneDrive",
  as.character(file.info(aps_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (aps_path)


# Warning: Expecting numeric in B144102 / R144102C2: got 'blank'
# 2024-05-08: APS data imported with 568562 rows and 11 columns.
# Data last modified on OneDrive 2024-03-21 18:35:52 
```

## USPS Zip Code Validation Data

The United States Postal Service releases an Excel file detailing ZIP Codes with their associated Area and District Codes. This includes State data for a State-level verification of Zip Code values. This file used the version obtained on the [USPS website](https://postalpro.usps.com/ZIP_Locale_Detail), last updated May 03, 2024.

```{r}
usps_path <- here::here("data","USPS_ZIP_Locale_Detail.xls")
usps_zip <- readxl::read_excel(usps_path,
  # Select only the desired data
                  col_types = c(
                    rep("skip", 4), "text", rep("skip", 2), rep("text", 3),
                    "skip"
                    ),
                  col_names = c(
                    'delivery_zip', 'city', 'state', 'phys_zip'
                    ),
                  # skips row of headers
                  skip = 1
                  ) |>
  # Remove rows with duplicated rows
  dplyr::distinct()

# Print import message for broad checks.
cat(
  paste0(Sys.Date(), ":"),
  "USPS Zip Code data imported with", nrow(usps_zip), "rows and", ncol(usps_zip), "columns.\n",
  "Data last modified on OneDrive",
  as.character(file.info(usps_path)$mtime), "\n"
)

# Remove path from memory, no longer needed
rm (usps_path)


# 2024-05-08: USPS Zip Code data imported with 43307 rows and 4 columns.
# Data last modified on OneDrive 2024-05-06 14:48:02 
```

We performed a modification of the USPS data so that it acted as a dictionary, with the zip code as the unique key.

```{r}
# Alter data so that ZIP CODE acts as a key, indicating the state associated
# with each ZIP CODE for Delivery (service) area and Physical (actual
# location of service delivery) for each ZIP CODE.

usps_zip <- dplyr::full_join(
  # Isolate State for Each Physical Zip Code
  usps_zip |>
    dplyr::select('state', 'phys_zip') |>
    dplyr::distinct() |>
    dplyr::rename_at(
      c('state', 'phys_zip'),
      ~c('usps_state_phys', 'client_zip_code')
    ) |>
    # Change value for any repeated Zip Code (multiple States for Physical)
    # so that each Zip is only present once
    dplyr::mutate(usps_state_phys = ifelse(
      (
        duplicated(client_zip_code)|
        duplicated(client_zip_code, fromLast = TRUE)
       ),
       'Multiple',
       usps_state_phys
      )
      ) |>
    dplyr::distinct(),
  # Isolate State for Each Delivery Zip Code
  usps_zip |>
    dplyr::select('state', 'delivery_zip') |>
    dplyr::distinct() |>
    dplyr::rename_at(
      c('state', 'delivery_zip'),
      ~c('usps_state_delivery', 'client_zip_code')
    ) |>
    # Change value for any repeated Zip Code (multiple States for Physical)
    # so that each Zip is only present once
    dplyr::mutate(usps_state_delivery = ifelse(
      (
        duplicated(client_zip_code)|
          duplicated(client_zip_code, fromLast = TRUE)
        ),
       'Multiple',
       usps_state_delivery
      )
      ) |>
    dplyr::distinct(),
  by = 'client_zip_code'
)
```

## County Data

We isolated a list of all counties in Texas using the [Texas Health and Human Services list of Texas Counties and Public Health Regions](https://www.dshs.texas.gov/center-health-statistics/center-health-statistics-texas-county-numbers-public-health-regions). As Texas HHS notes, counties may have a variety of valid spellings so counties which do not match the list are not necessarily invalid.

```{r}
url <- paste0(
  "https://www.dshs.texas.gov/center-health-statistics/center-health-",
  "statistics-texas-county-numbers-public-health-regions"
  )

# Scrape county list from table on webpage
web_data <- url |>
  rvest::read_html() |>
  rvest::html_elements('table') |>
  rvest::html_table()

# Extract desired column and enforce format
web_data <- web_data [[1]] |>
  dplyr::rename_at("County\n\tName", ~"county") |>
  dplyr::select(county) |>
  dplyr::mutate(county = tolower(county))

# Convert to list
counties <- pull(web_data)

# Purge unnecessary variables for memory management
rm(url)
rm(web_data)
```


# Initial Data Structure

## APS Data

The APS client data set contained 568,562 observations for 11 variables.

```{r}
dim(aps)

# [1] 568562     11
```

This included 378,418 unique Client ID values, which should be unique to each subject.

```{r}
length(unique(aps$client_id))

# [1] 378418
```

There was only one observation which was missing a value for Client ID, which was anticipated (was entered as "blank" in original Excel document).

```{r}
nrow(aps |>
       dplyr::filter(is.na(aps$client_id))
     )

# [1] 1
```

Per APS documentation (see notes documents in data folders), each APS Case should have one Client ID (Clients may have more than one Case, each Case only has one client, One-to-Many relationship of Client-Case). The data set initially included 568,385 values for Case ID, indicating some Case IDs possibly represented more than one observation (and thus possibly more than one Client ID was assigned to a Case ID).

```{r}
length(unique(aps$case_id))

# [1] 568385
```

There were 290,004 observations that contained a duplicated Client ID.

```{r}
nrow(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         )
     )

# [1] 290004
```

This represented 99,860 Client IDs and 289,975 Case IDs.

```{r}
cat("Client IDs:", 
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         ) |>
         dplyr::select(client_id)
      )),
    ";", "Case IDs:",
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(client_id) | duplicated(client_id, fromLast = TRUE)
         ) |>
         dplyr::select(case_id)
      ))
    )

# Client IDs: 99860 ; Case IDs: 289975
```

There were 351 observations that contained a duplicated Case ID.

```{r}
nrow(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         )
     )

# [1] 290004
```

This represented 99,860 Client IDs and 289,975 Case IDs. This indicated likely "failed matches" (one subject represented by more than one Client ID), likely due to human/system error in data entry.

```{r}
cat("Client IDs:", 
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         ) |>
         dplyr::select(client_id)
      )),
    ";", "Case IDs:",
    nrow(unique(aps |> 
       dplyr::filter(
         duplicated(case_id) | duplicated(case_id, fromLast = TRUE)
         ) |>
         dplyr::select(case_id)
      ))
    )

# Client IDs: 349 ; Case IDs: 174
```

There were 27,161 unique values in the field for first names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_first_name') |>
  dplyr::arrange(value) |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 27161
```

There were 7,588 unique values in the field for middle names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_middle_name') |>
  dplyr::arrange(value) |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 7588
```

There were 57,846 unique values in the field for middle names. These were extracted for a brief manual examination for trends and potential issues.

```{r}
checking <- get_unique_value_summary(aps, 'client_last_name') |>
  dplyr::arrange(value) |>
  dplyr::mutate(row_num = row_number())

nrow(checking)

# 57846
```

# Data Validation and Modification

Data required some validation and modification to maximize returns from fastLink processing. First, all leading and trailing white space was removed from any string values, and values were converted to lowercase.

```{r}
aps <- aps |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~tolower(stringr::str_trim(., side = 'both'))
                ))
```

We also reduced any instances of multiple white spaces ("  ") into a single white space, for consistency.

```{r}
aps <- aps |>
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name', 'client_street_address', 
                  'client_city', 'client_state', 'client_county'
                  ), 
                  ~stringr::str_replace_all(.x, "( {2,})", " ")
                ))
```


## Name Fields

Names values were already separated into First, Middle Initial, and Last.

### "Unknown"

We inspected name values for "Unknown", a common placeholder that is better represented by a missing value. We found 75 observations with a potential value for "Unknown" in at least one name field.

```{r}
target_regex <- "(unkn)|(don't)|(homel)|(unk\\.)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 75
```

Several of these observations had potentially valuable information for subject matching, specifically "male" or "female" in one of the name fields along with a value for "unknown". We shifted these gender values into a notes column, and converted those values to missing (`NA`) values.

```{r}
aps <- aps |>
  # Initiate columns
  dplyr::mutate(
    client_msc = NA_character_, 
    client_msc_first = NA_character_,
    client_msc_last = NA_character_,
    client_msc_middle = NA_character_
  ) |>
  # Shift from first, middle, and last name field to a notes column
  dplyr::mutate(
    # Shift "male" or "female" from first name to notes field
    client_msc_first = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_first_name == 'male' ~ 'male', 
        client_first_name == 'female' ~ 'female',
        TRUE ~ client_msc_first
      ),
      client_msc_first),
    client_first_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_first_name == 'male' ~ NA_character_,
        client_first_name == 'female' ~NA_character_,
        TRUE ~ client_first_name
      ),
      client_first_name
      )
  ) |>
  dplyr::mutate(
    # Shift "male" or "female" from Middle name to notes field
    client_msc_middle = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_middle_name == 'male' ~ 'male', 
        client_middle_name == 'female' ~ 'female',
        TRUE ~ client_msc_middle
      ),
      client_msc_middle),
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_middle_name == 'male' ~ NA_character_,
        client_middle_name == 'female' ~NA_character_,
        TRUE ~ client_middle_name
      ),
      client_middle_name
      )
  ) |>
  dplyr::mutate(
    # Shift "male" or "female" from last name to notes field
    client_msc_last = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_last_name == 'male' ~ 'male', 
        client_last_name == 'female' ~ 'female',
        TRUE ~ client_msc_last
      ),
      client_msc_last),
    client_last_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        client_last_name == 'male' ~ NA_character_,
        client_last_name == 'female' ~NA_character_,
        TRUE ~ client_last_name
      ),
      client_last_name
      )
  ) |>
  # Collect data into a single, neat notes column with NAs omitted
  dplyr::mutate(
    client_msc = paste(
      client_msc_first, client_msc_middle, client_msc_last, 
      sep = "; "
      ),
    client_msc = stringr::str_remove_all(client_msc, "NA; "),
    client_msc = stringr::str_remove_all(client_msc, "; NA"),
    client_msc = stringr::str_remove_all(client_msc, "NA"),
    client_msc = ifelse(client_msc == '', NA_character_, client_msc)
  ) |>
  # Remove temporary columns
  dplyr::select(-c(client_msc_first, client_msc_middle, client_msc_last))
```

A point-fix was utilized to correct the only entry with "don't know" in a name field.

There were also several observations that contained "unknown" in one name field with either "person" or "ward" as the only other potentially informative value, both of which were better expressed as missing (`NA`) values in this context. There were no names such as "Edward" that would otherwise be valid but caught in our regular expressions within this set. üî¥ Any modification to this data processing pipeline should include verification that this is still true to avoid loss of valuable data.

```{r}
aps <- aps |>
  # "don't know" in middle name
  dplyr::mutate(
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      ifelse(
        client_middle_name == "don't know",
        NA_character_,
        client_middle_name
      ),
      client_middle_name
      )
  ) |>
    # Remove names that are "person" or "ward" that were caught in "Unknown"
    # name checks
  dplyr::mutate(
    # First name
    client_first_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_first_name, '(person)') ~ NA_character_, 
        stringr::str_detect(client_first_name, '(ward)') ~ NA_character_,
        TRUE ~ client_first_name
      ),
      client_first_name),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_middle_name, '(person)') ~ NA_character_,
        stringr::str_detect(client_middle_name, '(ward)') ~NA_character_,
        TRUE ~ client_middle_name
      ),
      client_middle_name
      ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id,
      dplyr::case_when(
        stringr::str_detect(client_last_name, '(person)') ~ NA_character_,
        stringr::str_detect(client_last_name, '(ward)') ~NA_character_,
        TRUE ~ client_last_name
      ),
      client_last_name
      )
  )
```

We were then able to set any of our "unknown" name values to missing values, maintaining helpful data.

```{r}
aps <- aps |> 
  dplyr::mutate(
    client_first_name = ifelse(
      stringr::str_detect(client_first_name, target_regex),
      NA_character_,
      client_first_name
    ),
    client_middle_name = ifelse(
      stringr::str_detect(client_middle_name, target_regex),
      NA_character_,
      client_middle_name
    ),
    client_last_name = ifelse(
      stringr::str_detect(client_last_name, target_regex),
      NA_character_,
      client_last_name
    )
  )
```

We additionally identified 8 rows with a name value of "none". We isolated these observations for manual examination.

```{r}
target_regex <- "^(none)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 8
```

We determined that all of the "none" values likely represented an "unknown" value, and converted those values to missing values.

```{r}
aps <- aps |> 
  dplyr::mutate(
    client_first_name = ifelse(
      stringr::str_detect(client_first_name, target_regex),
      NA_character_,
      client_first_name
    ),
    client_middle_name = ifelse(
      stringr::str_detect(client_middle_name, target_regex),
      NA_character_,
      client_middle_name
    ),
    client_last_name = ifelse(
      stringr::str_detect(client_last_name, target_regex),
      NA_character_,
      client_last_name
    )
  )
```

Due to the US convention of naming unknown subjects "Jane Doe" or "John Doe", we checked for rows where the last name was "doe". These 6 rows were isolated for manual review. All appeared to be potentially valid instances of a subject with the last name of "Doe", rather than an anonymous placeholder.

```{r}

checking <- aps |> 
  dplyr::filter(
    client_last_name == 'doe'
    )

nrow (checking)

# [1] 6
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

### Numbers in Names

In previous checks, several name fields were identified which had numbers rather than name data. Names do not typically contain numerical digits, but numerical digits may frequently occur as a typographical or system error in entry. We isolated 11 entries with a numerical digit in any name field.

```{r}
target_regex <- "([0-9]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 11
```

There were two observations that merited a point-fix to shift potentially useful data into our new notes field.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Subject with a name of "trailer #10"
    client_msc = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      'trailer #10',
      client_msc
      ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      NA_character_,
      client_first_name
      ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "#10",
      NA_character_,
      client_last_name
      ),
    # Possibly important numbers in a last name
    client_msc = ifelse(
      case_id %in% checking$case_id & client_last_name == "44947",
      '44947',
      client_msc
      ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & client_last_name == "44947",
      NA_character_,
      client_last_name
      )
  )
```


Numbers were otherwise omitted from all name fields. Empty strings were converted into missing values.

```{r}
 aps <- aps |>
  dplyr::mutate(
    client_first_name = stringr::str_remove_all(
      client_first_name, target_regex
      ),
    client_middle_name = stringr::str_remove_all(
      client_middle_name, target_regex
      ),
    client_last_name = stringr::str_remove_all(
      client_last_name, target_regex
      )
  ) |>
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

### Unexpected Characters (non A-Z or a-z)

We expected most, if not all, names in our subset to consist only of the letters A-Z without special characters, punctuation, or other characters.

#### Hyphens (-)

The most common character we expected to be validly present was a hyphen (-), due to traditions of hyphenating names. We isolated 4,785 entries with a hyphen in any name field for manual review.

```{r}
target_regex <- "([-]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 4785
```
 
While all 4,785 observation had a valid use of hyphens, some modification was still required due to the inconsistent use of white space with hyphenated names (i.e. Smith-Jones as "smith- jones", "smith -jones", or "smith-jones"). As such, we stripped white space surrounding hyphens from observations in our data set. This was complicated due to valid use of hyphens and spaces in multi-part names (e.g. "de la cruz- smith") in first and last name fields.
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, ' -', '-'),
      client_first_name
    ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, '- ', '-'),
      client_first_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, ' -', '-'),
      client_last_name
    ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, '- ', '-'),
      client_last_name
    )
  )
```

We checked for any instances with more than one consecutive hyphen ("--", etc.) after the initial corrections. We isolated the 8 observations for manual review.

```{r}
target_regex <- "(-{2,})"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 8
```

The instances of multiple hyphens all appeared within last name values. We adjusted these entries to ensure only a single hyphen was present.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, '-'),
      client_last_name
    )
  )
```

We checked for any instances where a hyphen was the first character in the field. We identified 0 occurrences.

```{r}
target_regex <- "^(-)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 0
```

We checked for any instances where a hyphen was the last character in the field. We identified 4 occurrences.

```{r}
target_regex <- "(-)$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 4
```

We adjusted these entries to trim the trailing hyphen.

```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, target_regex, ''),
      client_first_name
    ),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, target_regex, ''),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, ''),
      client_last_name
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Double Quote (") and quote-surrounded nicknames.
 
Several subjects appeared to have names in double quotation marks, particularly in the middle name field. These values were likely to represent nicknames or aliases. We isolated 14 entries with names surrounded by double-quotes, present in both the first and middle name fields.

```{r}
target_regex <- '(["]+)'

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 14
```
 
We shifted these likely nickname values into our notes field, and removed them from the name fields. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, '(".*?")'),
      client_msc
    ),
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, '(".*?")'),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, '(".*?")'),
      client_middle_name
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, '(".*?")'),
      client_first_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```
 
We assessed for similar entries using single quotes rather than double quotes, and found a single observation with a single quote nickname in the first name field.

```{r}
target_regex <- "('.*?')+"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 1
```

We shifted this likely nickname values into our notes field, and removed it from the name field. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, "('.*?')"),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, "('.*?')"),
      client_first_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We assessed for similar entries using parentheses rather than double quotes, and found two observations with a parenthesis surrounded nickname (first name and middle name fields)

```{r}
target_regex <- "(\\(.*?\\))+"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 2
```

We shifted these likely nickname values into our notes field, and removed them from the name fields. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, "(\\(.*?\\))"),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, "(\\(.*?\\))"),
      client_first_name
    ),
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, "(\\(.*?\\))"),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, "(\\(.*?\\))"),
      client_middle_name
    ), 
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

In the examination of name values, we also identified a single nickname that appeared to be indicated in the middle name field, preceded by "goes by". We isolated this observation for further evaluation.

```{r}
target_regex <- "goes by (.*)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 1
```

We shifted this likely nickname value into our notes field, and removed it from the middle name field. 
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, "goes by (.*)"),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, "goes by (.*)"),
      client_middle_name
    ), 
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Single Quotes (')

Single quotes (') may be valid and commonly present in some names, such as in Irish and Scottish conventions (e.g. "O'Brien"). We isolated 682 entries with a single quote in any name field for manual review. 

```{r}
target_regex <- "([']+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 681
```

While most occurrences of single quotes appeared to be valid, modification was still required due to the inconsistent use of white space with single quotes in names (i.e. O'Brien as "o'brien", "o' brien", "o 'brien", or "o ' brien"). As such, we stripped white space surrounding single quotes from observations in our data set. This was complicated due to valid use of hyphens and spaces in multi-part names (e.g. "de la cruz- smith") in the name fields.

Additionally, we were unable to correct for what appeared to be usage of a single quote when a hyphen was appropriate (i.e. "Smith-Jones" as "smith'jones") due to the complexity of generating a solution without sizable point-fixes with small potential benefit to string-matching after correction.
 
```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, " '", "'"),
      client_first_name
    ),
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, "' ", "'"),
      client_first_name
    ),
  # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, " '", "'"),
      client_middle_name
    ),
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, "' ", "'"),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, " '", "'"),
      client_last_name
    ),
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, "' ", "'"),
      client_last_name
    )
  )
```

We checked for any instances where a single quote was the first character in the field. We identified no occurrences.

```{r}
target_regex <- "^(')"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 0
```

We checked for any instances where a single quote was the last character in the field. We identified 13 occurrences.

```{r}
target_regex <- "(')$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 13
```

We adjusted these entries to trim the trailing single quote.

```{r}
aps <- aps |>
  dplyr::mutate(
    # First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_replace_all(client_first_name, target_regex, ''),
      client_first_name
    ),
    # Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_replace_all(client_middle_name, target_regex, ''),
      client_middle_name
    ),
    # Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_replace_all(client_last_name, target_regex, ''),
      client_last_name
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Examination for suffixes

JR and SR are common suffixes to names, but may artificially increase string-distance. We isolated 157 entries with a potential suffix match in any name field for manual review. 

```{r}
target_regex <- "((junior)|(senior)|(jr)|(sr))[^a-z]?$"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 157
```

Suffix items appeared in all fields. Values were shifted from middle name and last name fields, but left in first name fields as these are also possible initial-isms or otherwise valid first names.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from Middle Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_match(client_middle_name, target_regex),
      client_msc
    ),
    # Remove from Middle Name
    client_middle_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_middle_name, target_regex),
      stringr::str_remove(client_middle_name, target_regex),
      client_middle_name
    ),
    # Extract from Last Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_match(client_last_name, target_regex),
      client_msc
    ),
    # Remove from Last Name
    client_last_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_last_name, target_regex),
      stringr::str_remove(client_last_name, target_regex),
      client_last_name
    )
  ) |>
  # Convert empty strings to missing values
  dplyr::mutate(across(
    c(client_first_name, client_middle_name, client_last_name),
    ~dplyr::na_if(., '')
    )
  )
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

#### Potential titles in name fields

Mr., Ms., Mrs., and Dr. are the primary titles used in the US. Sr. and Sra. are common Spanish-language titles used in the US. We isolated 14 potential occurrences for manual review.

```{r}
target_regex <- paste0(
  "^((doctor)|(mister)|(misus)|(miss)|(mrs)|(senora)|",
  "(senorita)|(senora)|(sra)|(ms)|(mr)|(sr)|(dr))(?![a-z]+)"
  )

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 14
```

All 11 potential titles were found in first name fields. Extraction was complicated by additional values within the field that were valuable (example: first name of "mr. smith" with no value in middle or last name fields) and values which simply required trimming (example: first name of "dr. john" with last name value of "doe").

First, we shifted desired values to our note ("client_msc") variable.

```{r}
aps <- aps |>
  dplyr::mutate(
    # Extract from First Name
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_match(client_first_name, target_regex),
      client_msc
    ),
    # Remove from First Name
    client_first_name = ifelse(
      case_id %in% checking$case_id & 
        stringr::str_detect(client_first_name, target_regex),
      stringr::str_remove(client_first_name, target_regex),
      client_first_name
    )
  )
```

Then, we identified our single row where there was no additional last name name information.

```{r}
target_row <- pull(aps |>
  dplyr::filter(
    (case_id %in% checking$case_id) & is.na(client_last_name)
    ) |>
  dplyr::select(case_id)
  )
```

We shifted the remaining information in the targeted observation's first name field into the last name field.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_last_name = ifelse(
      (case_id %in% checking$case_id &
        case_id == target_row),
      str_extract(client_first_name, "\\. ([a-z]+)"),
      client_last_name
    ),
    client_first_name = ifelse(
      (case_id %in% checking$case_id &
        case_id == target_row),
      NA_character_,
      client_first_name
    )
  )
```

We purged our checking subset, target regular expression, and target_row values for memory management.

```{r}
rm(checking)
rm(target_regex)
rm(target_row)
```

#### Removal of other unexpected characters

Any characters other than single quotes, hyphens, white spaces, or alphanumeric characters were no longer anticipated to be valid. We additionally set the Spanish Language character "√±" as acceptable. We isolated 2,254 potential occurrences for manual review.

```{r}
target_regex <- "([^a-z√± '-])"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_first_name, target_regex) |
      stringr::str_detect(client_middle_name, target_regex) |
      stringr::str_detect(client_last_name, target_regex)
    )

nrow (checking)

# [1] 2254
```

On review, all remaining unanticipated characters to a single white space, across all name fields.

```{r}
aps <- aps |>
  # Convert non-anticipated punctuation to white space
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(
                    case_id %in% checking$case_id,
                    stringr::str_replace_all(.x, target_regex, ""),
                    .x
                    )
                  )
                )
```

We then performed cleaning: multiple white spaces were converted to a single white space; leading and trailing white spaces were trimmed; and empty strings were converted to missing values.

```{r}
aps <- aps |>
  # Trim multiple white spaces to single white space
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(
                    case_id %in% checking$case_id,
                    stringr::str_replace_all(., "( {2,})", " "),
                    .
                    )
                  )
                ) |>
  # Trim leading and trailing white spaces
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~stringr::str_trim(., side = 'both')
                  )
                ) |>
  # Convert empty strings to missing values
  dplyr::mutate(dplyr::across(c(
                  'client_first_name', 'client_middle_name', 
                  'client_last_name'
                  ), 
                  ~ifelse(. == '', NA_character_, .)
                  )
                ) 
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(checking)
rm(target_regex)
```

## Address Fields

### Zip Codes

We expected ZIP codes to follow a 5-digit format. Many entries contained a 5+4 format (10 character, #####-#### format). Only 7 entries did not directly match either format. These were manually reviewed.

```{r}
checking <- aps |>
  dplyr::filter(nchar(client_zip_code) < 10) |>
  dplyr::filter(nchar(client_zip_code) != 5)

nrow(checking)

# [1] 7
```

4 Zip Codes were otherwise valid, but had leading zeros truncated by Excel. These were fixed by re-adding the leading zeroes to the string value for the zip code

```{r}
aps <- aps |>
  # Add leading 0s to truncated Zip Codes.
  dplyr::mutate(client_zip_code = dplyr::case_when(
    nchar(client_zip_code) == 3 ~ paste0("00", client_zip_code),
    nchar(client_zip_code) == 4 ~ paste0("0", client_zip_code),
    TRUE ~ client_zip_code)
    ) 
```

The remaining 3 observations appeared to be fixable by truncating to 5 digits, along with the remainder of the data set's 10 character values:

-   1 Zip Code had 5 digits which appeared to be otherwise valid, with a hyphen ("-") and no 4 digit addition to the zip code. This was fixed by truncating the hyphen so only the first 5 digits were kept.

-   2 Zip Codes had all 9 digits, but without the anticipated hyphen between the 5 and 4 digit components of zip code. These were fixed by truncating so only the first 5 digits were kept.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_zip_code = ifelse(
      nchar(client_zip_code)>5,
      substr(client_zip_code, start=1, stop=5),
      client_zip_code)
  )
```

We performed a state-level verification of Zip Code data using the USPS Zip Code service data. We identified 130 observations where the Client State did not match either the USPS physical or delivery service areas based on the Zip Code.

```{r}
checking <- aps %>%
  tibble::add_column(
    usps_state_phys = NA_character_, 
    usps_state_delivery = NA_character_
    ) |>
  # Add USPS data
  dplyr::rows_update(
    usps_zip, 
     by = "client_zip_code", 
     unmatched = "ignore"
  ) |>
  # Flag mismatches between USPS and APS state based on zip code
  dplyr::mutate(
    flag_physical_zip = dplyr::case_when(
      is.na(usps_state_phys) ~ FALSE,
      (!is.na(usps_state_phys) & !is.na(client_state)) & 
        (usps_state_phys == client_state) ~
        FALSE,
      (is.na(usps_state_phys) & is.na(client_state)) ~ FALSE,
      TRUE ~ TRUE
    ),
    flag_delivery_zip = dplyr::case_when(
      is.na(usps_state_delivery) ~ FALSE,
      (!is.na(usps_state_delivery) & !is.na(client_state)) & 
        (usps_state_delivery == client_state) ~
        FALSE,
      (is.na(usps_state_delivery) & is.na(client_state)) ~ FALSE,
      TRUE ~ TRUE
    ),
    flag_zip = ifelse(flag_physical_zip | flag_delivery_zip, TRUE, FALSE),
    # If it matched either physical or delivery, unflag the row
    flag_zip = dplyr::case_when(
      !is.na(usps_state_phys) & !flag_physical_zip ~ FALSE,
      !is.na(usps_state_delivery) & !flag_delivery_zip ~ FALSE,
      TRUE ~ flag_zip
    )
  ) |>
  # Extract only the flagged observations
  dplyr::filter(flag_zip) |>
  # Reorder variables for ease of manual checking
  dplyr::relocate(
    flag_zip, flag_physical_zip, flag_delivery_zip, client_zip_code,
    usps_state_phys, usps_state_delivery,
    client_city, client_county, client_state, client_street_address
    ) |>
  dplyr::arrange(client_zip_code)

nrow(checking)

# [1] 130
```

Manual review involved searching for street addresses (if provided) using Google Maps and comparison against remainder of the APS provided address data fields. The vast majority of point fixes involved an minor typographical error, or unusual entry of data (such as states within city fields). 

Point-fixes were made by calling data from the "checking" subset to avoid overwriting other entries with identical values for Case ID that were not flagged for manual review, minimizing collateral changes to the data.

There were 87 observations that were deemed to require no revision, largely due to ZIP codes that were along state borders (thus postal service crossed state lines for the given location). There were 6 observations with issues that were unable to be resolved, largely due to missing street addresses and/or conflicting results when searching for a reliable match. There were 37 observations that received point-fixes.

```{r}
# ZIP 28207 to 78207 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '28207') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78207'

# ZIP 32667 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '32667') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_


# ZIP 46502 to 76502 (3 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '46502') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76502'


# Entry for ZIP 48202 to City "DETROIT", State "MI", 
#county "OUT OF STATE" (2 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_city'] <- 'detroit'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'mi'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '48202') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

# ZIP 64114 to 77831 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '64114') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '77831'

# ZIP 67026 to 76028 (3 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '67026') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76028'

# Entry for ZIP 70125 State to "LA" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70125') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'la'

# ZIP 70526 to 78526 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70526') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78526'

# ZIP 70602  to 76579 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '70602') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76579'

# Entry for ZIP 73840 to 71854, state "AR", County "OUT OF STATE" (3 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'ar'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '73840') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '71854'


# ZIP 74067 to 78067 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74067') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78067'

# ZIP 74543 to 78543 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74543') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78543'

# ZIP 74756 state to OK (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '74756') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'ok'

# ZIP 78368 to a missing value (4 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78368') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# Entry for ZIP 78595 state "TX", county to a missing value (4 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78595') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'tx'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '78595') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- NA_character_

# Entry for ZIP 80102 to 79045, county to "DEAF SMITH" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80102') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'deaf smith'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80102') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '79045'

# ZIP 80134 to 76201 (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '80134') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '76201'

# Entry for ZIP 82331 state to "WY" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '82331') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'wy'

# Entry for ZIP 87575 state to 'NM', county to 'OUT OF STATE' (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '87575') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'nm'

aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '87575') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_county'] <- 'out of state'

# Entry for ZIP 88063 state to "NM" (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '88063') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_state'] <- 'nm'

# ZIP 88125 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '88125') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# ZIP 89420 to missing value; Non-US address (1 row)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '89420') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- NA_character_

# ZIP 97524 to 78852 (2 rows)
aps[aps$case_id %in% pull(
  checking |> 
    dplyr::filter(client_zip_code == '97524') |> 
    dplyr::select(case_id) |> 
    dplyr::distinct()
  ),'client_zip_code'] <- '78852'

```

We purged the USPS ZIP code data and our checking subset for memory management.

```{r}
rm(usps_zip)
rm(checking)
```

### States

We expected all values for state to represent US state values in two-character format (example: "TX") per [USPS standards](https://about.usps.com/who/profile/history/state-abbreviations.htm). With the inclusion of Puerto Rico (PR), District of Columbia (DC), and missing values (`NA`), we had 53 anticipated values. We isolated counts of our 62 unique state values for manual review.


```{r}
checking <- get_unique_value_summary(aps, 'client_state') |> 
  dplyr::arrange(value)

nrow(checking)
# [1] 62
```

All unanticipated values started with 'x' or 'z'. These 184 occurrences were isolated for further manual review.

```{r}
checking <- aps |>
  dplyr::filter(
    (stringr::str_starts(client_state, 'x') | 
       (stringr::str_starts(client_state, 'z'))
     )
    ) |>
  dplyr::arrange(client_state)

nrow(checking)

# [1] 184
```

Point fixes were determined and executed, with creation of a "Country" column:

-   "xd" and "zc" referred to addresses in Mexico
-   "xe" referred to addresses in Mexico and Peru

    -   Additional cleaning of the city was required for the Peru entries, which gave the city as "lima, peru"
    
-   "xf" referred to addresses in Great Britain
-   "za" referred to addresses in Canada
-   "ze" referred to addresses in Russia
-   "zh" referred to addresses in Honduras
-   "zj" referred to addresses in Lagos
-   "zl" referred to addresses in Taiwan

    -   Additional cleaning of the city was required as the city was given as "Taipei, Taiwan"

```{r}
aps <- aps |>
  # Initialize empty "Country" column
  dplyr::mutate(
    client_country = NA_character_
  ) |>
  dplyr::mutate(
    # "xe" entries for Lima, Peru
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xe' & client_city == "lima, peru"),
        'peru',
        client_country
      ),
    client_city = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xe' & client_city == "lima, peru"),
        'lima',
        client_city
      ),
    client_state = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xe' & client_city == "lima"),
        'resolved',
        client_state
      )
  ) |>
  dplyr::mutate(
  # "xd", xe", and "zc" entries for Mexico
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state %in% c('xd', 'xe', 'zc')),
        'mexico',
        client_country
      ),
# "xf" entries for Great Britain
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'xf'),
        'great britain',
        client_country
      ),
  # "za" entries for Canada
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'za'),
        'canada',
        client_country
      ),
  # "ze" entries for Russia
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'ze'),
        'russia',
        client_country
      ),
    # "zh" entries for Honduras
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zh'),
        'honduras',
        client_country
      ),
    # "zj" entries for Lagos
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zj'),
        'lagos',
        client_country
      ),
    # "zl" entries for Taiwan
    client_country = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zl'),
        'taiwan',
        client_country
      ),
    client_city = 
      ifelse(
        (case_id %in% checking$case_id) & 
          (client_state == 'zl'),
        'taipei',
        client_city
      ) 
  ) |>
  # Remove cleaned state entries
  dplyr::mutate(
    client_state = ifelse(
      case_id %in% checking$case_id,
      NA_character_,
      client_state
    )
  )
```

We also checked for any observation where the value for state was missing (without a country value indicating it was an out-of-country address), but ZIP code or county were present. We found no such remaining values.

```{r}
checking <- aps |>
  dplyr::filter(
    (is.na(client_state) & is.na(client_country)) & 
      (!is.na(client_zip_code)|!is.na(client_county))
  )

nrow(checking)
# [1] 0
```

We purged our checking subset for memory management.

```{r}
rm(checking)
```

### Counties

Observations listing the state as Texas were expected to indicate a Texas County, if any county. We isolated the 546 observations wherein the listed county was not present on our Texas HHS list of Counties for manual review.

```{r}
checking <- aps |>
  dplyr::mutate(
    flag_county = FALSE
  ) |>
  dplyr::mutate(
    flag_county = ifelse(
      client_state == 'tx' & !is.na(client_county),
      ifelse(!(client_county %in% counties),
             TRUE,
             flag_county
             ),
      flag_county
    )
  ) |>
  dplyr::filter(
    flag_county
    )

nrow(checking)
# [1] 546
```

On examination, this was due to 544 rows with a county of "de witt", and 2 with a county of "out of state". On review, "De Witt" county was contained in our verification list as "dewitt", making "de witt" valid.

```{r}
get_unique_value_summary(checking, 'client_county')
```

The two observations with values of "out of state" did indeed belong to out of state addresses, with one address belonging to Mexico. We targeted these observations for point-fixes.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_state = ifelse(
      case_id %in% checking$case_id & client_city == 'california',
      'ca',
      client_state
    ),
    client_country = ifelse(
      case_id %in% checking$case_id & client_city == 'nuevo leon',
      'mexico',
      client_country
    ),
    client_state = ifelse(
      case_id %in% checking$case_id & client_city == 'nuevo leon',
      NA_character_,
      client_state
    )
  )
```

We isolated the 1,793 observations that indicated a state of Texas but were missing a value for county for manual review. No information was contained in these observations (street address or city values) to suggest a non-Texas address. Individual street addresses were *not* individually checked using mapping software in this stage.

```{r}
checking <- aps |>
  dplyr::filter(client_state == 'tx' & is.na(client_county))

nrow(checking)
# [1] 1793
```

We isolated the 48 observations that did not indicate a state of Texas, but had a value for county that was not either a missing value or "out of state".

```{r}
checking <- aps |>
  dplyr::filter(
    (client_state != 'tx' | is.na(client_state)) &
       !is.na(client_county) & (client_county != 'out of state')
     )

nrow(checking)
# [1] 48
```

After manual review, we identified several cities which had valid counties (county with same name as a Texas county, but validly associated with the indicated city and/or zip code). We performed point fixes to an observation with an address close to a state line (state and zip code modification after address confirmation with Google Maps) and a city with a significant typo in the city name. We otherwise shifted all invalid county values to 'out of state'.

```{r}
target_cities <- c(
  'calico rock', 'debeque', 'denver', 'miramar', 'augusta', 'new orleans', 
  'new mexico', 'akron', 'unavailable', 'oklahoma', 'walters', 'yukon', 
  'varnville', 'coah'
  )

aps <- aps |>
  dplyr::mutate(
    # Fix "Anthony, NM" which refers to "Anthony, TX"
    client_zip_code = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'anthony',
      '79821',
      client_zip_code
    ),
    client_state = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'anthony',
      'tx',
      client_state
    ),
    # Fix found city name typo
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'allonia',
      'vallonia',
      client_city
    )
  ) |>
  dplyr::mutate(
    # Clear invalid county names
    client_county = ifelse(
      (case_id %in% checking$case_id) &
        client_city %in% target_cities,
      'out of state',
      client_county
    )
  )
```

We purged our target cities, list of counties, and checking subset for memory management.

```{r}
rm(checking)
rm(target_cities)
rm(counties)
```

### Cities

We expected values for cities to contain only letters, and no value that was equivalent to "unknown". Previous exploration had identified a city with a name of "unavailable" (which did not match any city/town in the US per Google searches) and at least one observation where the city name was a spelled out version of the state, when no such city was known to exist in the state.

#### Unanticipated characters

We first identified observations with any unanticipated characters (any non-letter, except a white space). We isolated these 26 observations for manual review.

```{r}
target_regex <- "([^a-z ]+)"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 26
```

We identified several issues which would require dedicated screening and modification: variations on "Fort Worth" or similar "Ft" or "Mt" city names, and a variation of "North Richland Hills" (caught due to periods). However, we did identify several issues (commas or backticks at the end of a city name which were likely typos, city name with a hyphen or forward slash indicating a region rather than a specific city/town) that could be fixed in this batch of corrections. We additionally performed point-fixes for observations which indicated a value in "CITY, STATE" format.

After point-fixes were made, all remaining unanticipated characters (anything other than a whitespace, single quote, or letter from a-z) were removed. Multiple white spaces were consolidated into a single white space. Leading and trailing white spaces were trimmed. Empty strings were converted to missing values.

```{r}
target_regex <- "([^a-z ']+)"

aps <- aps |>
  dplyr::mutate(
    # Shift value for Torreon, Coahuila
    client_msc = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'torreon, coahuila',
      'torreon, coahuila',
      client_msc),
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'torreon, coahuila',
      'torreon',
      client_city),
    # Shift value for Argyle - North Lake to Argyle
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'argyle - north lake',
      'argyle',
      client_city),    
    # Shift value for Wylie/Dallas Area
    client_msc = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'wylie/dallas area',
      'wylie/dallas area',
      client_msc),
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'wylie/dallas area',
      'wylie',
      client_city),    
    # Shift value for "Dallas, Texas" in city field
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        client_city == 'dallas, texas',
      'dallas',
      client_city)
  ) |>
  # Remove all non-desired characters
  dplyr::mutate(
    client_city = ifelse(
      case_id %in% checking$case_id,
      stringr::str_replace_all(client_city, target_regex, ''),
      client_city
    )
  ) |>
  # Consolidate multiple white spaces into a single white space
  dplyr::mutate(
    client_city = stringr::str_replace_all(client_city, "( {2,})", " ")
  ) |>
  # Trim leading and trailing white spaces
  dplyr::mutate(
    client_city = stringr::str_trim(client_city, side = 'both')
  ) |> 
  # Convert empty strings to missing values
  dplyr::mutate(
    client_city = dplyr::na_if(client_city, '')
  )
```

#### Prefixes and Suffixes

In previous data, city values with prefixes of "City of", "Town of", "Village of", or "Census Designated Place" as well as suffixes of "historical" were identified. We checked our current data for any such values, and found no matches.

```{r}
target_regex <- "((census)|(histor)|(village of)|(town of)|(city of))"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 0
```

#### Unknown or Equivalents

In previous exploration and cleaning, we identified a city value of "unavailable" which was not valid for any area in the US. Similarly, there is no known city named "Unknown" in the US. Previous data had values for a city of "Uncertain", which could be a valid city in a Texas. We checked our current data for any values for "unknown" or it's equivalents, isolating the 27 matches for manual review.

```{r}
target_regex <- "((unkn)|(unav)|(uncer))"

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 27
```

All entries indicated an unknown value, with an equally missing or otherwise "unknown" value for street address. No potentially valid cities were identified when searching individual states. As such, we shifted all of these values to a missing value.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_city = ifelse(
      stringr::str_detect(client_city, target_regex),
      NA_character_,
      client_city
    )
  )
```

#### State Names in Cities

While there are several cities which include state names (such as Oklahoma City and New York City), there have been previously identified instances within the data set wherein a city actually includes the state name. R contains a built-in data set which includes state names and abbreviations.

```{r}
state_data <- data.frame(name = state.name, abbr = state.abb) |>
  # Convert string fields to lowercase values
  dplyr::mutate(dplyr::across(dplyr::everything(), ~tolower(.x))) |>
  # Arrange values from longest to shortest, and alphabetically within
  # the same length
  dplyr::mutate(name_length = stringr::str_length(name)) |>
  dplyr::arrange(dplyr::desc(name_length), name)
```


We checked our data for any city name that contained a state name, and found 4,861 matches. We isolated these matches for further manual review.

```{r}
target_regex <- paste0(
  "(",
  paste(state_data$name, collapse = ")|("), ")"
)

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 4861
```

While the vast majority of cities were determined to be valid, we also identified several cities which required revision. Four of these could be targeted to the city name, but additional revisions required further specification.

```{r}
target_cities <- c(
  'louisiana', 'new mexico', 'pennsylvania', 'south carolina'
  )

aps <- aps |>
  dplyr::mutate(
    # Street address includes ' santa fe', no zip code
    client_zip_code = ifelse(
      (case_id %in% checking$case_id) & client_city == 'texas' &
        (stringr::str_detect(client_street_address, ' santa fe')),
      '77510',
      client_zip_code
    ),
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '77510'),
      'santa fe',
      client_city
    ),
    client_street_address = ifelse(
      (case_id %in% checking$case_id) & client_city == 'santa fe',
      stringr::str_remove(client_street_address, ' santa fe'),
      client_street_address
    ),
  # Street address includes ", galveston"
    client_street_address = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '77551'),
      stringr::str_remove(client_street_address, ', galveston,'),
      client_street_address
    ),
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '77551'),
      'galveston',
      client_city
    ),
    # City from ZIP Code
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'texas' & client_zip_code == '79902'),
      'el paso',
      client_city
    ),
    # Oregon, NM specifically as invalid
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city == 'oregon' & client_state == 'nm'),
      NA_character_,
      client_city
    ),    
    # Adding 'city' to 'New York' and 'Oklahoma' cities
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        (client_city %in% c('new york', 'oklahoma')),
      stringr::str_c(client_city, ' city'),
      client_city
    ),
    # Point-fix of single address, ZIP code issue
    client_zip_code = ifelse(
      (case_id %in% checking$case_id) & 
        (client_zip_code == '77831'),
      '64414',
      client_zip_code
    ),
    # Remove cities of 'florida' in the state of florida only
    client_city = ifelse(
      (case_id %in% checking$case_id) &
        (client_city == 'florida' & client_state == 'fl'),
      NA_character_,
      client_city
    )
  ) |>
  # Broader correction based on target list
  dplyr::mutate(
    client_city = ifelse(
      (case_id %in% checking$case_id) & 
        (client_city %in% target_cities),
      NA_character_,
      client_city
    )
  )
```

We similarly checked for any values which contained the two letter state abbreviation at the end of a city value (example: "dallas tx"). We isolated the 14 matching rows for manual review.
   
```{r}
target_regex <- paste0(
  "[^a-z]+((", 
  paste(pull(state_data |> 
               dplyr::arrange(name) |> 
               dplyr::select(abbr)), 
        collapse = ")|("), 
  "))$"
  )

checking <- aps |> 
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
    )

nrow (checking)
# [1] 14
```

All 14 values followed the formula "city tx", and had state values of "tx". As such, we trimmed the extraneous data.

```{r}
aps <- aps |>
  dplyr::mutate(
    client_city = ifelse(
      case_id %in% checking$case_id,
      stringr::str_remove(client_city, ' tx'),
      client_city
    )
  )
```

We purged our memory of our target regular expression, list of target cities, state name and abbreviation data, and our checking subset for memory management.

```{r}
rm(target_regex)
rm(target_cities)
rm(state_data)
rm(checking)
```

#### Standardizing Format of "Fort" and "Mt" City Names
  
In prior exploration and cleaning, we observed several components of city names which may or may not be abbreviated - with multiple formats included in values. This includes Fort Worth (abbreviated to "Ft Worth"), Mount Pleasant (abbreviated to Mt Pleasant). It also included cardinal direction indicators, such as North Richland Hills (abbreviated to N Richland Hills). This cleaning was required to minimize string distances from otherwise identical values.

We isolated the 27,681 observations which contained these values for examination.

```{r}
target_regex <- paste0(
  "^((mount)|(fort)|(ft)|(mt)|(north)|(south)|(east)|(west)|",
  "(port)|(point)|(prt)|(pnt)|(pt)|",
  "(nw )|(ne )|(sw )|(se )|(s )|(e )|(w )|(n ))"
)

checking <- aps |>
  dplyr::filter(
    stringr::str_detect(client_city, target_regex)
  )

nrow(checking)
# 27681
```

In examining these values, we find 153 unique variations of city name, and are able to identify broader trends.

```{r}
get_unique_value_summary(checking, 'client_city') |>
  dplyr::arrange(value)
```

Before any aggregate modifications, several point-fixes were made. This was primarily to correct several misspellings, or adjust city based on zip code.

```{r}
aps <- aps |>
  # "WEST" Cluster
  dplyr::mutate(
    # adjust ZIP code of 76654 in 'west, tx' to 76691
    client_zip_code = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'west' & client_zip_code == 76654),
      '76691',
      client_zip_code
    ),
    # fix typo in 'columbia'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west colombia',
      'west columbia',
      client_city
    ),
    # convert 'west ingram' into 'ingram'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west ingram',
      'ingram',
      client_city
    ),
    # fix typo in 'west tawakoni'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west towankani',
      'west tawakoni',
      client_city
    ),
    # add 'city' back to 'west valley city'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'west valley',
      'west valley city',
      client_city
    ),
    # adjust ZIP code of 79549 in 'westbrook, tx' to 79565
    client_zip_code = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'westbrook' & client_zip_code == 79549),
      '79565',
      client_zip_code
    ),
    # remove 'westheimer, tx' city (this is a road name)
    client_msc = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'westheimer',
      'westheimer',
      client_msc
    ),
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'westheimer',
      NA_character_,
      client_city
    )
  ) |>
  # SOUTH Cluster
  dplyr::mutate(
    # convert 'south austin' to 'austin'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'south austin',
      'austin',
      client_city
    ),    
    # convert 'south clifton' to 'clinton'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'south clifton',
      'clinton',
      client_city
    ),    
    # convert 'south haven' to 'southaven'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'south haven',
      'southaven',
      client_city
    ),    
  ) |>
  # NORTH Cluster
  dplyr::mutate(
    # Convert 'n richland hills' with ZIP of 76118 to 'richland hills'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'n richland hills' & client_zip_code =='76118'),
      'richland hills',
      client_city
    ),    
    # convert 'north richard hills' with ZIP of 76187 to 76182
    client_zip_code = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'north richard hills' & client_zip_code == 76187),
      '76182',
      client_zip_code
    ),    
    # Consolidate version of 'north richland hills
    client_city = ifelse(
      case_id %in% checking$case_id &
        (client_city %in% c(
          'n richlnd hls', 'north richard hills', 'north richland hills', 'n richland hills'
        )),
      'north richland hills',
      client_city
    ),
    # convert 'north stone mountain' to 'stone mountain'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'north stone mountain',
      'stone mountain',
      client_city
    )
  ) |>
  # FORT Cluster
  dplyr::mutate(
    # convert 'fort blvd' to 'port bolivar'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fort blvd',
      'port bolivar',
      client_city
    ),    
    # convert 'forthancock' to 'fort hancock'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'forthancock',
      'fort hancock',
      client_city
    ),    
    # convert 'fort mc kavett' to 'fortt mckavett'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fort mc kavett',
      'fort mckavett',
      client_city
    ),    
    # 'fort worth' + ZIP 76180 + street address that DOES NOT include
    # 'riverview', 'manor', 'deaver', 'susan', or 'green castle'
    # to 'north richland hills'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'fort worth' & client_zip_code == '76180' &
           !stringr::str_detect(
             client_street_address, 
             "((green castle)|(riverview)|(deaver)|(manor)|(susan))")),
      'north richland hills',
      client_city
    ),        
    # 'fort worth' + ZIP 76182 + street address that DOES NOT include 'buck'
    # to 'north richland hills'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        (client_city == 'fort worth' & client_zip_code == '76182' &
           !stringr::str_detect(
             client_street_address, 
             "(buck)")),
      'north richland hills',
      client_city
    ),   
    # convert 'fort fort' to 'fort worth'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fort fort',
      'fort worth',
      client_city
    ),    
    # convert 'fortworth' to 'fort worth'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'fortworth',
      'fort worth',
      client_city
    ),    
    # convert 'forth worth' to 'fort worth'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'forth worth',
      'fort worth',
      client_city
    )
  ) |>
  # MOUNT Cluster
  dplyr::mutate(
    # convert 'mount pleasent' to 'mount pleasant'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'mount pleasent',
      'mount pleasant',
      client_city
    ),
    # convert 'mount vernont' to 'mount vernon'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'mount vernont',
      'mount vernon',
      client_city
    )
  )|>
  # POINT/PORT Cluster
  dplyr::mutate(
    # convert 'pointe' to 'point'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'pointe',
      'point',
      client_city
    ),
    # convert 'point blank' to 'pointblank'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'point blank',
      'pointblank',
      client_city
    ),
    # convert 'port boliver' to 'port bolivar'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'port boliver',
      'port bolivar',
      client_city
    ),
    # convert 'port isable' to 'port isabel'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'port isable',
      'port isabel',
      client_city
    ),
    # convert 'port lacaca' to 'port lavaca'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city == 'port lacaca',
      'port lavaca',
      client_city
    ),
    # consolidate 'port atrthor', 'port autrthor', and 'port acres'
    # into 'port arthur'
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city %in% c(
          'port atrthor', 'port autthor', 'port acres'
          ),
      'port arthur',
      client_city
    ),
    # consolidate 'port o connor' and 'port oconnor' into 
    # "port o'connor"
    client_city = ifelse(
      case_id %in% checking$case_id & 
        client_city %in% c(
          'port oconnor', 'port o connor'
          ),
      "port o'connor",
      client_city
    )
  )
```

We then made more systematic modifications. These modifications aimed to minimize variance in string distances, while maintaining important distance values.
-   Cardinal direction prefixes to city names were converted to a single letter abbreviation

    -   Cardinal directions only appeared as single word values (such as 'south', but not 'southeast')
    
-   'Mt' would be expanded to 'Mount'
-   'Ft' prefixes would be expanded to 'Fort'
-   No modifications would be made to "Point" or "Port" prefixes, as no occurences of abbreviations were found to currently exist (and the words themselves are fairly short)

```{r}
aps <- aps |>
  dplyr::mutate(
    # cardinal directions
    client_city = ifelse(
      stringr::str_detect(client_city, '^(east )'),
      stringr::str_replace(client_city, '^(east )', 'e '),
      client_city
    ),  
    client_city = ifelse(
      stringr::str_detect(client_city, '^(west )'),
      stringr::str_replace(client_city, '^(west )', 'w '),
      client_city
    ),  
    client_city = ifelse(
      stringr::str_detect(client_city, '^(north )'),
      stringr::str_replace(client_city, '^(north )', 'n '),
      client_city
    ),  
    client_city = ifelse(
      stringr::str_detect(client_city, '^(south )'),
      stringr::str_replace(client_city, '^(south )', 's '),
      client_city
    ),  
    # 'mt' to 'mount'
    client_city = ifelse(
      stringr::str_detect(client_city, '^(mt)'),
      stringr::str_replace(client_city, '^(mt)', 'mount'),
      client_city
    ),
    # 'ft' to 'fort'
    client_city = ifelse(
      stringr::str_detect(client_city, '^(ft)'),
      stringr::str_replace(client_city, '^(ft)', 'fort'),
      client_city
    )
    
  ) 
```

We purged our checking subset and target regular expression for memory management.

```{r}
rm(target_regex)
rm(checking)
```


# üíæ
